{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"1. Dom\u00f3tica \u00b6 Seg\u00fan la Wikipedia \"se llama dom\u00f3tica a los sistemas capaces de automatizar una vivienda o edificaci\u00f3n de cualquier tipo, aportando servicios de gesti\u00f3n energ\u00e9tica, seguridad, bienestar y comunicaci\u00f3n, y que pueden estar integrados por medio de redes interiores y exteriores de comunicaci\u00f3n, cableadas o inal\u00e1mbricas, y cuyo control goza de cierta ubicuidad, desde dentro y fuera del hogar. Se podr\u00eda definir como la integraci\u00f3n de la tecnolog\u00eda en el dise\u00f1o inteligente de un recinto cerrado.\" El t\u00e9rmino dom\u00f3tica viene de la uni\u00f3n de las palabras domus (casa en lat\u00edn) y aut\u00f3nomo (del griego: \u03b1\u1f50\u03c4\u03cc\u03bd\u03bf\u03bc\u03bf\u03c2; \u201cque se gobierna a s\u00ed mismo\u201d). Existen multitud de tecnolog\u00edas y protocolos que definen todo lo relacionado con dom\u00f3tica. El t\u00e9rmino dom\u00f3tica se usa para referirse a viviendas, cuando aplicamos el concepto a inmuebles se inm\u00f3tica y cuando lo aplicamos a ciudades urb\u00f3tica . Podemos resumir los conceptos de la forma siguiente: Dom\u00f3tica . Conjunto de tecnolog\u00edas aplicadas al control y la automatizaci\u00f3n inteligente de la vivienda, que permite una gesti\u00f3n eficiente del uso de la energ\u00eda, aporta seguridad, confort y comunicaci\u00f3n entre el usuario y el sistema. Inm\u00f3tica . Conjunto de tecnolog\u00edas aplicadas al control y la automatizaci\u00f3n inteligente de edificios no destinados a vivienda, como hoteles, centros comerciales, escuelas, universidades, hospitales y edificios terciarios, permitiendo una gesti\u00f3n eficiente del uso de la energ\u00eda, adem\u00e1s de aportar seguridad, confort, y comunicaci\u00f3n entre el usuario y el sistema. Urb\u00f3tica . Conjunto de servicios e instalaciones p\u00fablicas urbanas que se encuentran automatizadas con el fin de mejorar la gesti\u00f3n energ\u00e9tica, la seguridad, el bienestar, el confort y las comunicaciones de todos los usuarios de estos servicios p\u00fablicos. A continuaci\u00f3n vemos un listado de t\u00e9rminos que escucharemos habitualmente cuando hablamos de dom\u00f3tica: Interruptor crepuscular Actuador Automatizaci\u00f3n Detector Estaci\u00f3n meteorol\u00f3gica autom\u00e1tica Hogar digital HomeOS. Sistema operativo para dom\u00f3tica desarrollado por Microsoft Ingenier\u00eda mecatr\u00f3nica Inm\u00f3tica Internet de las Cosas (IoT) Interruptor Reconocimiento de gestos Red dom\u00e9stica Red el\u00e9ctrica inteligente Robot dom\u00e9stico Tarjeta SIM Teleasistencia Telemedicina Urb\u00f3tica Wi-Fi Direct CSI (bus serie). Bus serie para c\u00e1maras De estas modalidades aqu\u00ed solamente hablaremos de dom\u00f3tica y en cuanto a aplicaci\u00f3n real a simulaciones con elementos pensados para la ense\u00f1anza. 1.1. Dom\u00f3tica real \u00b6 Cuando hablamos de dom\u00f3tica nos referimos a crear casas inteligentes, lo que las har\u00e1 mas seguras en cosas como automatizar el alumabrado para que parezca que estamos en casa, comprobar a distancia si las puertas y ventanas est\u00e1n cerradas, que dispositivos tengo activos, etc. Pero tambi\u00e9n debemos hablar de eficiencia energ\u00e9tica en cosas tan sencillas como que las luces se enciendan cuando nos acercamos y por supuesto de confort, es decir automatizar para hacernos la vida mas f\u00e1cil. La mejor forma de saber que automatizar es pensar y anotar aquellas cosas repetitivas que hacemos para automatizarlas. Para esto hay que abstraerse de todo aquello que hacemos de manera autom\u00e1tica y sin pensarlo simplemente porque estamos muy acostumbrados a hacerlo. Algunas ideas de cosas para automatirzar un piso o casa unifamiliar: Control remoto de persianas y ventanas. Control del calentamiento del agua en remoto. Control del consumo energ\u00e9tico. Iluminaci\u00f3n automatizada por presencia o por nivel de luz. Control de calefacci\u00f3n y ventilaci\u00f3n el\u00e9ctrica. Control autom\u00e1tico de riego de plantas. Encendido y apagado de dispositivos en remoto. Control autom\u00e1tico de puertas de garage. Notificaciones en el m\u00f3vil de eventos que ocurren en los controles. Cuando hablamos de dom\u00f3tica la forma mas sencilla y econ\u00f3mica de implantarla es utilizando conexiones inal\u00e1mbricas dada su flexibilidad y no requerir de t\u00e9cnicos especialistas. Si por el contrario hablamos de inm\u00f3tica o urb\u00f3tica el sistema cableado es sin duda el mejor, lo que no significa que se descarte totalmente el uso de dispositivos inal\u00e1mbricos. 1.2. Protocolos para dom\u00f3tica \u00b6 Antes de nada debemos decidir que sistema o lenguaje de comunicaci\u00f3n van a usar nuestros dispositivos. Seg\u00fan el protocolo que elijamos quedar\u00e1n determinados los dispositivos y opciones futuras que deber\u00e1n ser compatibles. Veamos brevemente cuales son los protocolos. X10 . No necesita cableado porque utiliza los propios cables el\u00e9ctricos para establecer las comunicaciones. Totalmente en desuso. UPB . L\u00edneas el\u00e9ctricas como bus universal (Universal Powerline Bus). Es un protocolo que vino a corregir las deficiencias del X10. INSTEON . Utiliza una tecnolog\u00eda mixta de comunicaci\u00f3n a trav\u00e9s de l\u00edneas el\u00e9ctricas e inal\u00e1mbrica. En desuso. Z-Wave . Tecnolog\u00eda est\u00e1ndar para la dom\u00f3tica inal\u00e1mbrica. Es una red en malla que utiliza ondas de radio de baja energ\u00eda para que los dispositivos se comuniquen. Los dispositivos funcionan tambi\u00e9n como repetidores permitiendo hasta 230 dispositivos en un solo controlador. Es compatible para todos los fabricantes que forman parte de su alianza. En este enlace a eedomus documentaci\u00f3n podemos consultar la lista de dispositivos Z-Wave probados. ZigBee . Muy similar a Z-Wave con mayor consumo y radiaci\u00f3n que esta. No se recomienda utilizar dispositivos de distintos fabricantes. Wi-Fi . Uitiliza la red WiFi para el control de dispositivos. Su principal ventaja es lo f\u00e1cil que es de utilizar y su principal problema es que requiere un gran ancho de banda para que los dispositivos inteligentes no tengan latencia por la interferencia de ordenadores, tablets, m\u00f3viles, etc. Hay que tener en cuenta que el WiFi consume bastante energ\u00eda por lo que las bater\u00edas o pilas de los dispositivos son un factor a tener en consideraci\u00f3n. Bluetooth . Es la forma sencilla y segura de comunicarnos con dispositivos cuando las distancias son cortas (puertas o luces). Se suelen encontrar en sistemas h\u00edbridos con ZWave o Zigbee. Como controladores por voz debemos buscar la compatibilidad con Google Home, Alexa o Apple para despu\u00e9s comprobar que dispositivos son compatibles con \u00e9l.","title":"1. Introducci\u00f3n"},{"location":"#1-domotica","text":"Seg\u00fan la Wikipedia \"se llama dom\u00f3tica a los sistemas capaces de automatizar una vivienda o edificaci\u00f3n de cualquier tipo, aportando servicios de gesti\u00f3n energ\u00e9tica, seguridad, bienestar y comunicaci\u00f3n, y que pueden estar integrados por medio de redes interiores y exteriores de comunicaci\u00f3n, cableadas o inal\u00e1mbricas, y cuyo control goza de cierta ubicuidad, desde dentro y fuera del hogar. Se podr\u00eda definir como la integraci\u00f3n de la tecnolog\u00eda en el dise\u00f1o inteligente de un recinto cerrado.\" El t\u00e9rmino dom\u00f3tica viene de la uni\u00f3n de las palabras domus (casa en lat\u00edn) y aut\u00f3nomo (del griego: \u03b1\u1f50\u03c4\u03cc\u03bd\u03bf\u03bc\u03bf\u03c2; \u201cque se gobierna a s\u00ed mismo\u201d). Existen multitud de tecnolog\u00edas y protocolos que definen todo lo relacionado con dom\u00f3tica. El t\u00e9rmino dom\u00f3tica se usa para referirse a viviendas, cuando aplicamos el concepto a inmuebles se inm\u00f3tica y cuando lo aplicamos a ciudades urb\u00f3tica . Podemos resumir los conceptos de la forma siguiente: Dom\u00f3tica . Conjunto de tecnolog\u00edas aplicadas al control y la automatizaci\u00f3n inteligente de la vivienda, que permite una gesti\u00f3n eficiente del uso de la energ\u00eda, aporta seguridad, confort y comunicaci\u00f3n entre el usuario y el sistema. Inm\u00f3tica . Conjunto de tecnolog\u00edas aplicadas al control y la automatizaci\u00f3n inteligente de edificios no destinados a vivienda, como hoteles, centros comerciales, escuelas, universidades, hospitales y edificios terciarios, permitiendo una gesti\u00f3n eficiente del uso de la energ\u00eda, adem\u00e1s de aportar seguridad, confort, y comunicaci\u00f3n entre el usuario y el sistema. Urb\u00f3tica . Conjunto de servicios e instalaciones p\u00fablicas urbanas que se encuentran automatizadas con el fin de mejorar la gesti\u00f3n energ\u00e9tica, la seguridad, el bienestar, el confort y las comunicaciones de todos los usuarios de estos servicios p\u00fablicos. A continuaci\u00f3n vemos un listado de t\u00e9rminos que escucharemos habitualmente cuando hablamos de dom\u00f3tica: Interruptor crepuscular Actuador Automatizaci\u00f3n Detector Estaci\u00f3n meteorol\u00f3gica autom\u00e1tica Hogar digital HomeOS. Sistema operativo para dom\u00f3tica desarrollado por Microsoft Ingenier\u00eda mecatr\u00f3nica Inm\u00f3tica Internet de las Cosas (IoT) Interruptor Reconocimiento de gestos Red dom\u00e9stica Red el\u00e9ctrica inteligente Robot dom\u00e9stico Tarjeta SIM Teleasistencia Telemedicina Urb\u00f3tica Wi-Fi Direct CSI (bus serie). Bus serie para c\u00e1maras De estas modalidades aqu\u00ed solamente hablaremos de dom\u00f3tica y en cuanto a aplicaci\u00f3n real a simulaciones con elementos pensados para la ense\u00f1anza.","title":"1. Dom\u00f3tica"},{"location":"#11-domotica-real","text":"Cuando hablamos de dom\u00f3tica nos referimos a crear casas inteligentes, lo que las har\u00e1 mas seguras en cosas como automatizar el alumabrado para que parezca que estamos en casa, comprobar a distancia si las puertas y ventanas est\u00e1n cerradas, que dispositivos tengo activos, etc. Pero tambi\u00e9n debemos hablar de eficiencia energ\u00e9tica en cosas tan sencillas como que las luces se enciendan cuando nos acercamos y por supuesto de confort, es decir automatizar para hacernos la vida mas f\u00e1cil. La mejor forma de saber que automatizar es pensar y anotar aquellas cosas repetitivas que hacemos para automatizarlas. Para esto hay que abstraerse de todo aquello que hacemos de manera autom\u00e1tica y sin pensarlo simplemente porque estamos muy acostumbrados a hacerlo. Algunas ideas de cosas para automatirzar un piso o casa unifamiliar: Control remoto de persianas y ventanas. Control del calentamiento del agua en remoto. Control del consumo energ\u00e9tico. Iluminaci\u00f3n automatizada por presencia o por nivel de luz. Control de calefacci\u00f3n y ventilaci\u00f3n el\u00e9ctrica. Control autom\u00e1tico de riego de plantas. Encendido y apagado de dispositivos en remoto. Control autom\u00e1tico de puertas de garage. Notificaciones en el m\u00f3vil de eventos que ocurren en los controles. Cuando hablamos de dom\u00f3tica la forma mas sencilla y econ\u00f3mica de implantarla es utilizando conexiones inal\u00e1mbricas dada su flexibilidad y no requerir de t\u00e9cnicos especialistas. Si por el contrario hablamos de inm\u00f3tica o urb\u00f3tica el sistema cableado es sin duda el mejor, lo que no significa que se descarte totalmente el uso de dispositivos inal\u00e1mbricos.","title":"1.1. Dom\u00f3tica real"},{"location":"#12-protocolos-para-domotica","text":"Antes de nada debemos decidir que sistema o lenguaje de comunicaci\u00f3n van a usar nuestros dispositivos. Seg\u00fan el protocolo que elijamos quedar\u00e1n determinados los dispositivos y opciones futuras que deber\u00e1n ser compatibles. Veamos brevemente cuales son los protocolos. X10 . No necesita cableado porque utiliza los propios cables el\u00e9ctricos para establecer las comunicaciones. Totalmente en desuso. UPB . L\u00edneas el\u00e9ctricas como bus universal (Universal Powerline Bus). Es un protocolo que vino a corregir las deficiencias del X10. INSTEON . Utiliza una tecnolog\u00eda mixta de comunicaci\u00f3n a trav\u00e9s de l\u00edneas el\u00e9ctricas e inal\u00e1mbrica. En desuso. Z-Wave . Tecnolog\u00eda est\u00e1ndar para la dom\u00f3tica inal\u00e1mbrica. Es una red en malla que utiliza ondas de radio de baja energ\u00eda para que los dispositivos se comuniquen. Los dispositivos funcionan tambi\u00e9n como repetidores permitiendo hasta 230 dispositivos en un solo controlador. Es compatible para todos los fabricantes que forman parte de su alianza. En este enlace a eedomus documentaci\u00f3n podemos consultar la lista de dispositivos Z-Wave probados. ZigBee . Muy similar a Z-Wave con mayor consumo y radiaci\u00f3n que esta. No se recomienda utilizar dispositivos de distintos fabricantes. Wi-Fi . Uitiliza la red WiFi para el control de dispositivos. Su principal ventaja es lo f\u00e1cil que es de utilizar y su principal problema es que requiere un gran ancho de banda para que los dispositivos inteligentes no tengan latencia por la interferencia de ordenadores, tablets, m\u00f3viles, etc. Hay que tener en cuenta que el WiFi consume bastante energ\u00eda por lo que las bater\u00edas o pilas de los dispositivos son un factor a tener en consideraci\u00f3n. Bluetooth . Es la forma sencilla y segura de comunicarnos con dispositivos cuando las distancias son cortas (puertas o luces). Se suelen encontrar en sistemas h\u00edbridos con ZWave o Zigbee. Como controladores por voz debemos buscar la compatibilidad con Google Home, Alexa o Apple para despu\u00e9s comprobar que dispositivos son compatibles con \u00e9l.","title":"1.2. Protocolos para dom\u00f3tica"},{"location":"2_1_kitsmarthome/","text":"2.1. El kit \u00b6 La idea b\u00e1sica es simular el funcionamiento de una casa inteligente o Smart Home de la vida real, bas\u00e1ndose en la programaci\u00f3n con Arduino. El kit incluye toda la estructura de la casa, el sistema de control basado en Arduino y m\u00faltiples sensores y actuadores para poder realizar diferentes tipos de acciones como, por ejemplo, encender el aire acondicionado y el calentador de agua, abrir la cerradura electr\u00f3nica de la puerta y la luz antes de llegar a casa. En la Figura 2.1.1 vemos el aspecto del kit. Figura 2.1.1. Aspecto del kit En la Figura 2.1.2 podemos ver las dimensiones del kit una vez montado. Figura 2.1.2. Dimensiones del kit montado En la Figura 2.1.3 vemos desplegado todo el material contenido de la caja y que vamos a desglosar en el apartado de ensamblado. Figura 2.1.3. Todo el contenido del kit En la Figura 2.1.4 podemos observar la smart home desde diferentes \u00e1ngulos. Figura 2.1.4. Vistas de la smart home","title":"2.1. El kit"},{"location":"2_1_kitsmarthome/#21-el-kit","text":"La idea b\u00e1sica es simular el funcionamiento de una casa inteligente o Smart Home de la vida real, bas\u00e1ndose en la programaci\u00f3n con Arduino. El kit incluye toda la estructura de la casa, el sistema de control basado en Arduino y m\u00faltiples sensores y actuadores para poder realizar diferentes tipos de acciones como, por ejemplo, encender el aire acondicionado y el calentador de agua, abrir la cerradura electr\u00f3nica de la puerta y la luz antes de llegar a casa. En la Figura 2.1.1 vemos el aspecto del kit. Figura 2.1.1. Aspecto del kit En la Figura 2.1.2 podemos ver las dimensiones del kit una vez montado. Figura 2.1.2. Dimensiones del kit montado En la Figura 2.1.3 vemos desplegado todo el material contenido de la caja y que vamos a desglosar en el apartado de ensamblado. Figura 2.1.3. Todo el contenido del kit En la Figura 2.1.4 podemos observar la smart home desde diferentes \u00e1ngulos. Figura 2.1.4. Vistas de la smart home","title":"2.1. El kit"},{"location":"2_2_ensamble/","text":"2.2. Gu\u00eda de ensamblado \u00b6 Comenzamos por verificar que tenemos los tableros etiquetados con las letras A, B, C, D, E, F, G, H e I y la placa con el resto de partes y que est\u00e1n en buen estado. Todos los elementos los vemos en la figura 2.2.1. Figura 2.2.1. Tableros A a I y partes Los cables que utilizaremos en cada apartado son los que describimos seguidamente: Elementos con conector de 3 pines y servos Letra Funci\u00f3n Descripci\u00f3n Color del cable En el servo G Ground Es el negativo de la alimentaci\u00f3n Negro Conductor marr\u00f3n V VCC Es el positivo de la alimentaci\u00f3n Rojo Conductor rojo S Signal Es el cable de se\u00f1al Amarillo/Naranja Conductor naranja Elementos con conector de 4 pines Dispositivo Letras / Color del cable Dispositivo Letras / Color del cable Sensor de gas MQ-2 GND - Marr\u00f3n VCC - Rojo D0 - Naranja A0 - Amarillo Ventilador GND - Marr\u00f3n VCC - Rojo ENA - Naranja ENB - Amarillo LCD GND - Marr\u00f3n VCC - Rojo SDA - Naranja SCL - Amarillo Bluetooth VCC - Rojo GND - Marr\u00f3n Tx - Naranja Rx - Amarillo El m\u00f3dulo bluetooth tambi\u00e9n se puede conectar directamente en la placa Keyestudio v5.2. 2.2.1. Tablero A \u00b6 Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero A 4 Tornillos de cabeza redonda M3x10mm 4 Tuercas M3 4 Tornillos de cabeza redonda M2.5x10mm 4 Tuercas M2.5 2 M\u00f3dulos bot\u00f3n pulsador 1 LED blanco 1 Sensor de movimiento PIR 1 Pantalla LCD1602 1 Cable tipo dupont H-H de 4 pines 4 Cable tipo dupont H-H de 3 pines En la Figura 2.2.2 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.2. Tablero A y todos los componentes Fijamos al tablero el LED blanco, los dos sensores tipo bot\u00f3n y el sensor de presencia PIR utilizando los 4 tornillos M3x10mm y las 4 tuercas M3. Instalamos en su posici\u00f3n la pantalla LCD1602 utilizando los 4 tornillos M2.5x10mm y las 4 tuercas M2.5. En la Figura 2.2.3 vemos el aspecto del tablero A en este momento. Figura 2.2.3. Tablero A con los componentes montados Conectamos los 4 cables tipo dupont de 3 pines teniendo la precauci\u00f3n de que queden orientados para que coincidan las letras en cada extremo y pasamos el extremo contrario por la ranura que hay debajo. Conectamos el cable tipo dupont de 4 pines. 2.2.2. Tablero B \u00b6 Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero B 2 Tornillos de cabeza redonda M3x10mm 2 Tuercas M3 1 M\u00f3dulo rel\u00e9 1 Cable tipo dupont H-H de 3 pines En la Figura 2.2.4 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.4. Tablero B y todos los componentes Ensamblamos el m\u00f3dulo rel\u00e9 en el tablero con los 2 tornillos M3x10mm y las 2 tuercas M3. En la Figura 2.2.5 vemos el aspecto del tablero B en este momento. Figura 2.2.5. Tablero B con los componentes montados Conectamos el cable tipo dupont de 3 pines teniendo la precauci\u00f3n de que queden orientados para que coincidan las letras en cada extremo y pasamos el extremo contrario por la ranura que hay a la derecha del rel\u00e9. 2.2.3. Ensamblar tableros A y B \u00b6 Para fijar los tableros A y B utilizamos un burl\u00f3n tipo T. El material para este paso lo vemos en la Figura 2.2.6. Figura 2.2.6. Materiales para el ensamblado de los tableros A y B El resultado y la posici\u00f3n del burl\u00f3n lo podemos apreciar en la Figura 2.2.7. Figura 2.2.7. Ensamblado de los tableros A y B 2.2.4. Tablero C \u00b6 Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero C 1 Tornillo de cabeza redonda M3x10mm 2 Tornillos de cabeza avellanada M3x10mm 3 Tuercas M3 1 Sensor de gas MQ-2 1 Soporte para 6 pilas o bater\u00edas AA 1 Cable tipo dupont H-H de 4 pines El soporte para pilas va dotado de un conector DC macho de \u00d8_int. 2.1mm y \u00d8_ext. 5.5mm que deja al conjunto listo para alimentar la placa de control. En la Figura 2.2.8 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.8. Tablero C y todos los componentes Fijamos el soporte para pilas al tablero C utilizando los dos tornillos M3x10mm de cabeza avellanada y 2 tuercas M3. Ahora instalamos el m\u00f3dulo sensor de gases MQ-2 en el tablero C utilizando el tornillo M3x10 de cabeza redonda y la tuerca M3 restante. En la Figura 2.2.9 vemos el aspecto del tablero B en este momento. Figura 2.2.9. Tablero C con los componentes montados Conectamos el cable tipo dupont de 4 pines al MQ-2 teniendo la precauci\u00f3n de que queden orientados para que coincidan las letras en cada extremo y pasamos el extremo contrario por la ranura que hay debajo del sensor. 2.2.6. Tablero D \u00b6 Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero D 1 Tablero 1 4 Tornillos de cabeza redonda M3x12mm 4 Tuercas M3 autoblocantes 2 Tornillos de cabeza redonda M2x12mm 2 Tuercas M2 4 Tornillos autoroscantes M1.2x5mm 1 Tornillo de cabeza redonda M2x5mm 1 Engranaje 1 Servo motor 9g 1 Cruz de montaje En la Figura 2.2.10 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.10. Tablero D y todos los componentes Antes de colocar el servo en su posici\u00f3n debemos proceder a rotarlo 90\u00ba. Para ello vamos a conectar el servo al conjunto de placas tal y como vemos en la Figura 2.2.11. Figura 2.2.11. Servo conectado al pin 10 para rotarlo 90\u00ba Conectamos el servo al pin 10 de la shield V5 y le grabamos el programa que vemos en la Figura 2.2.12. Esta tarea se puede realizar en cualquier otro pin de la placa. La conexi\u00f3n del servo la realizamos teniendo en cuenta los colores vistos al principio del apartado. Figura 2.2.12. Programa para rotar el servo 90\u00ba Una vez que subimos el programa a la placa el servo queda rotado 90\u00ba. Fijamos el servo en su lugar utilizando los 2 tornillos de cabeza redonda M2x12mm y 2 tuercas M2x12. Despu\u00e9s instalamos el tablero 1 en el tablero D utilizando los 4 tornillos de cabeza redonda M3x12mm y las 4 tuercas autoblocantes. En la Figura 2.2.13 vemos el aspecto del tablero B en este momento. Figura 2.2.13. Tablero D con el servo y el tablero 1 montados Fijamos la cruz blanca al engranaje con los 4 tornillos autoroscantes M1.2x5mm tal y como vemos en la Figura 2.2.14. Figura 2.2.14. Fijaci\u00f3n de la cruz del servo al engranaje Montamos el engranaje en el servo motor fij\u00e1ndolo con el tornillo M2x5mm. Pasamos el cable del servo por la ranura y tendremos el panel en el estado que vemos en la Figura 2.2.15. Figura 2.2.15. Tablero D con los componentes montados Problema montaje servo \u00b6 En la imagen siguiente vemos el problema que se plantea al colocar el engranaje del servo en el mismo. Los dientes apenas coinciden lo que puede originar un funcionamiento err\u00f3neo o peor a\u00fan, un desgaste de los dientes que hagan inservible al engranaje. El problema se detecta cuando se programa el servo y se comprueba que no se mueve de forma correcta. Mal alineamiento de engranajes La soluci\u00f3n que he optado por darle es dise\u00f1ar e imprimir dos peque\u00f1as piezas que act\u00faen a modo de distanciador y que dejen alineado ambos engranajes. En la imagen siguiente vemos las piezas, donde van colocadas y el resultado final una vez puesto todo en su lugar. Buen alineamiento de engranajes Aunque se trata de una pieza muy sencilla de dise\u00f1ar, siguiendo fiel a mi costumbre, pongo en los enlaces el archivo fuente ( posicionador.FCStd ) y el archivo stl ( posicionador-servo.stl ) por si los necesitas. 2.2.6. Ensamblar tableros C y D \u00b6 Para fijar los tableros C y D utilizamos un burl\u00f3n tipo T. El material para este paso lo vemos en la Figura 2.2.16. Figura 2.2.16. Materiales para el ensamblado de los tableros C y D El resultado y la posici\u00f3n del burl\u00f3n lo podemos apreciar en la Figura 2.2.17. Figura 2.2.17. Ensamblado de los tableros C y D 2.2.7. Tablero E \u00b6 Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero E 1 Tornillo de cabeza redonda M3x10mm 1 Tuerca M3 1 LED amarillo 1 Cable tipo dupont H-H de 3 pines En la Figura 2.2.18 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.18. Tablero E y todos los componentes Montamos el LED amarillo en su lugar el tornillo M3x10mm de cabeza redonda y la tuerca M3. En la Figura 2.2.19 vemos el aspecto del tablero B en este momento. Figura 2.2.19. Tablero E con los componentes montados Conectamos el cable tipo dupont de 3 pines al sensor la precauci\u00f3n de orientar el conector de forma correcta. 2.2.8. Tablero H \u00b6 Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero H 2 Tablero 2 2 Engranajes 8 Tornillos de cabeza redonda M3x6mm 1 Tornillo de cabeza redonda M3x10mm 1 Tuerca M3 2 Tornillos de cabeza redonda M2x12mm 2 Tuercas M2 4 Separadores hexagonales M3x10mm 4 Tornillos autoroscantes M1.2x5mm 1 Tornillo de cabeza redonda M2x5mm 1 Servo motor 9g 1 Pala de montaje 1 Zumbador pasivo 1 Cable tipo dupont H-H de 3 pines 1 Placa de control Keyestudio PLUS 1 Placa Sensor shield En la Figura 2.2.20 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.20. Tablero H y todos los componentes Montamos los 4 separadores en el tablero H sujet\u00e1ndolos con 4 tornillos M3x6mm y fijamos el zumbador pasivo con un tornillo M3x10mm y una tuerca M3, tal y como vemos en la Figura 2.2.21. Figura 2.2.21. Tablero H con separadores y zumbador Rotamos el servo 90\u00ba de la misma forma que hicimos en el apartado \" 2.2.6: Tablero D \" antes de instalarlo en su lugar utilizando dos tornillos M2x12mm y dos tuercas M2. Fijamos la placa de control keyestudio PLUS a los 4 separadores utilizando 4 tornillos M3x6mm. En la Figura 2.2.22 vemos como queda el conjunto una vez dados los pasos anteriores. Figura 2.2.22. Tablero H con placa de control, zumbador y servo Ensamblados las dos piezas 'Tablero 2' y atornillamos la pala de montaje al engranaje tal y como vemos en la Figura 2.2.23. Figura 2.2.23. Ensable de Tablero 2 y pala a engranaje Fijar el engranaje con la cruz de montaje en el servo utilizando un tornillo M2x5mm (incluido con el servo). Ahora instalamos la combinaci\u00f3n de los dos tableros numerados con el 2 y el otro engranaje en el lugar correspondiente del tablero H para que quede algo como lo que vemos en la Figura 2.2.24. Figura 2.2.24. Tablero H con los componentes montados Finalmente conectamos el cable tipo dupont de 3 pines al zumbador teniendo la precauci\u00f3n de orientar el conector de forma correcta y colocamos la placa 'sensor shield' en la placa de control keyestudio PLUS. El conjunto del tablero H tendr\u00e1 el aspecto de la Figura 2.2.25. Figura 2.2.25. Tablero H finalizado 2.2.9. Ensamblar A,B,C,D,E y H \u00b6 Se trata de unir utilizando burlones en T el ensambles A y B, el ensamble C y D y los paneles E y H. El conector de alimentaci\u00f3n de la placa control PLUS debe quedar alineado con el orificio 8 del tablero B, y el conecto USB debe quedar alineado con el orificio 7 del mismo tablero. En la Figura 2.2.26 vemos los materiales que vamos a necesitar para este paso. Figura 2.2.26. Materiales para ensamblar los paneles A,B,C,D,E y H En la Figura 2.2.27 vemos detalles del ensamblaje. Figura 2.2.27. Detalles de ensamblaje de los paneles A,B,C,D,E y H En la figura 2.2.28 vemos el montaje final con los 6 tableros ensamblados. Figura 2.2.28. Ensamble de tableros A,B,C,D,E y H finalizado 2.2.10: Tablero F \u00b6 Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero F 3 Tornillos de cabeza redonda M3x10mm 3 Tuercas M3 1 Sensor de vapor (Steam Sensor) 1 Sensor fotoc\u00e9lula o LDR 1 M\u00f3dulo motor DC con ventilador 2 Cable tipo dupont H-H de 4 pines 1 Cable tipo dupont H-H de 3 pines En la Figura 2.2.29 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.29. Tablero F y todos los componentes Fijamos por separado el sensor de vapor, la fotoc\u00e9lula o LDR y el m\u00f3dulo ventilador en la placa F con 3 tornillos de cabeza redonda M3x10mm y 3 tuercas M3, posteriormente colocamos cables tipo dupont de 3 pines y 4 pines. En la Figura 2.2.30 vemos el aspecto del tablero F en este momento. Figura 2.2.30. Tablero F con los componentes montados 2.2.11: Conexionado \u00b6 Antes de poder finalizar el ansamblado de la smart home necesitamos conectar todos los m\u00f3dulos y sensores a la placa de control a trav\u00e9s de la Sensor Shield V5.2. Vamos a ir viendo paso a paso como hacer esta tarea, en la que debemos prestar especial atenci\u00f3n al sentido de colocaci\u00f3n de los conectores y al n\u00famero de pin que va conectado cada uno. De esta forma tendremos tambi\u00e9n una gu\u00eda de conexiones que nos resultar\u00e1 util cuando iniciemos los retos de programaci\u00f3n. Por partes \u00b6 Seg\u00fan el proceso de montaje seguido ya tendremos conectado un extremo de los cables dupont de 3 \u00f3 4 pines a los pines del sensor o al m\u00f3dulo, ahora toca conectar el otro extremo a la placa Sensor Shield V5.2. Tambi\u00e9n conectaremos los dos servos en este paso. En la tabla siguiente vemos de manera gr\u00e1fica y descriptiva las conexiones de todos los elementos. Sensor - m\u00f3dulo en sensor en shield N\u00ba Esquema Rel\u00e9 LED blanco G - V - S G - V - S G - V - 12 G - V - 13 6 1 Motor DC, m\u00f3dulo ventilador GND - VCC - INA - INB G - V - 7 - 6 15 Bot\u00f3n izquierdo LED amarillo G - V - S G - V - S G - V - 4 G - V - 5 3 12 Zumbador Sensor PIR G - V - S G - V - S G - V - 3 G - V - 2 16 5 Bot\u00f3n derecho Sensor gas MQ-2 G - V - S GND - VCC - D0 - A0 G - V - 8 G - V - 11 - A0 4 10 Sensor de vapor Sensor humedad fotocelula LDR G - V - S G - V - S G - V - S G - V - A3 G - V - A2 G - V - A1 13 - 14 Servo puerta Servo ventana Marr\u00f3n - Rojo - Naranja Marr\u00f3n - Rojo - Naranja G - V - 9 G - V - 10 17 11 Pantalla LCD1602 GND - VCC - SDA - SCL GND - VCC - SDA - SCL (IIC) 2 M\u00f3dulo bluetooth VCC - GND - TXD - RXD 5V - GND - RXD - TXD (COM) - Completo \u00b6 En la Figura 2.2.31 vemos el esquema de conexionado completo. Figura 2.2.31. Esquema de conexiones A continuaci\u00f3n tenemos la tabla de conexiones expresadas mediante texto. Sensor - m\u00f3dulo en sensor en shield Rel\u00e9 G - V - S G - V - 12 LED blanco G - V - S G - V - 13 Motor DC, m\u00f3dulo ventilador GND - VCC - INA - INB G - V - 7 - 6 Bot\u00f3n izquierdo G - V - S G - V - 4 LED amarillo G - V - S G - V - 5 Zumbador G - V - S G - V - 3 Sensor PIR G - V - S G - V - 2 Bot\u00f3n derecho G - V - S G - V - 8 Sensor gas MQ-2 GND - VCC - D0 - A0 G - V - 11 - A0 Sensor de vapor G - V - S G - V - A3 Sensor humedad G - V - S G - V - A2 Fotocelula LDR G - V - S G - V - A1 Servo puerta Marr\u00f3n - Rojo - Naranja Marr\u00f3n - Rojo - Naranja G - V - 9 Servo ventana Marr\u00f3n - Rojo - Naranja Marr\u00f3n - Rojo - Naranja G - V - 10 Pantalla LCD1602 GND - VCC - SDA - SCL GND - VCC - SDA - SCL (IIC) M\u00f3dulo bluetooth VCC - GND - TXD - RXD 5V - GND - RXD - TXD (COM) Detalles \u00b6 El aspecto de la smart home con todas las conexiones realizadas lo vemos en la Figura 2.2.32, donde se han conectado mediante cables tipo dupont tanto el sensor de humedad como el m\u00f3dulo bluetooth. Este \u00faltimo puede insertarse directamente en la shield pero como vamos a realizar diferentes programaciones de la placa es conveniente tenerlo a mano para poder desconectarlo y conectarlo de forma sencilla. Figura 2.2.32. Smart home con todas las conexiones La conexi\u00f3n del m\u00f3dulo bluetooth se realiza con 4 cables tipo dupont M-H dado que en la shield las conexiones disponibles en el puerto COM son hembra. El orden de conexiones lo vemos en la tabla siguiente: M\u00f3dulo bluetooth Sensor shield V5.2 Descripci\u00f3n VCC 5V Positivo de alimentaci\u00f3n GND GND Negativo de alimentaci\u00f3n TXD RXD Conexi\u00f3n cruzada de Tx con Rx RXD TXD Conexi\u00f3n cruzada de Rx con Tx Como se indica en la tabla los pines de transmisi\u00f3n y recepci\u00f3n de ambas placas deben cruzarse de modo que ambas se 'escuchen' entre si. En la Figura 2.2.33 vemos el tablero F colocado en su lugar y el m\u00f3dulo bluetooth colocado sobre la shield V5.2. Figura 2.2.33. M\u00f3dulo bluetooth y tablero F colocados 2.2.12: Ensamblar tableros F y G \u00b6 Para fijar el tablero F utilizaremos el material que vemos en la Figura 2.2.34, es decir, el tablero ya montado, dos tornillos de cabeza redonda M3x10mm, dos tuercas y los dos burlones que vemos en la Figura. Figura 2.2.34. Materiales para el ensamblado del tablero F El tablero G solamente requiere colocarlo en su lugar y sujetarlo con dos burlones en T. El resultado, la posici\u00f3n de los burlones para el tablero G y el tablero F colocado lo podemos apreciar en la Figura 2.2.35. Figura 2.2.35. Ensamblado de los tableros F y G 2.2.13: Ensamblado del suelo \u00b6 Este es el paso final de ensamblado del kit. El material que necesitamos para llevarlo a cabo es el que vemos en la Figura 2.2.36, el tablero del suelo y 6 burlones en T. Figura 2.2.36. Materiales para el ensamblado del tablero del suelo Teniendo especial cuidado de que el ensamble de los tableros 2 y el engranaje de la puerta queden colocados en su lugar, posicionamos el suelo y lo sujetamos con los burlones para obtener el resultado que vemos en la Figura 2.2.37. Figura 2.2.37. Suelo ensamblado En la Figura 2.2.38 vemos el montaje finalizado y listo para empezar a programarlo. Figura 2.2.38. Kit completamente montado","title":"2.2. Gu\u00eda de ensamblado"},{"location":"2_2_ensamble/#22-guia-de-ensamblado","text":"Comenzamos por verificar que tenemos los tableros etiquetados con las letras A, B, C, D, E, F, G, H e I y la placa con el resto de partes y que est\u00e1n en buen estado. Todos los elementos los vemos en la figura 2.2.1. Figura 2.2.1. Tableros A a I y partes Los cables que utilizaremos en cada apartado son los que describimos seguidamente: Elementos con conector de 3 pines y servos Letra Funci\u00f3n Descripci\u00f3n Color del cable En el servo G Ground Es el negativo de la alimentaci\u00f3n Negro Conductor marr\u00f3n V VCC Es el positivo de la alimentaci\u00f3n Rojo Conductor rojo S Signal Es el cable de se\u00f1al Amarillo/Naranja Conductor naranja Elementos con conector de 4 pines Dispositivo Letras / Color del cable Dispositivo Letras / Color del cable Sensor de gas MQ-2 GND - Marr\u00f3n VCC - Rojo D0 - Naranja A0 - Amarillo Ventilador GND - Marr\u00f3n VCC - Rojo ENA - Naranja ENB - Amarillo LCD GND - Marr\u00f3n VCC - Rojo SDA - Naranja SCL - Amarillo Bluetooth VCC - Rojo GND - Marr\u00f3n Tx - Naranja Rx - Amarillo El m\u00f3dulo bluetooth tambi\u00e9n se puede conectar directamente en la placa Keyestudio v5.2.","title":"2.2. Gu\u00eda de ensamblado"},{"location":"2_2_ensamble/#221-tablero-a","text":"Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero A 4 Tornillos de cabeza redonda M3x10mm 4 Tuercas M3 4 Tornillos de cabeza redonda M2.5x10mm 4 Tuercas M2.5 2 M\u00f3dulos bot\u00f3n pulsador 1 LED blanco 1 Sensor de movimiento PIR 1 Pantalla LCD1602 1 Cable tipo dupont H-H de 4 pines 4 Cable tipo dupont H-H de 3 pines En la Figura 2.2.2 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.2. Tablero A y todos los componentes Fijamos al tablero el LED blanco, los dos sensores tipo bot\u00f3n y el sensor de presencia PIR utilizando los 4 tornillos M3x10mm y las 4 tuercas M3. Instalamos en su posici\u00f3n la pantalla LCD1602 utilizando los 4 tornillos M2.5x10mm y las 4 tuercas M2.5. En la Figura 2.2.3 vemos el aspecto del tablero A en este momento. Figura 2.2.3. Tablero A con los componentes montados Conectamos los 4 cables tipo dupont de 3 pines teniendo la precauci\u00f3n de que queden orientados para que coincidan las letras en cada extremo y pasamos el extremo contrario por la ranura que hay debajo. Conectamos el cable tipo dupont de 4 pines.","title":"2.2.1. Tablero A"},{"location":"2_2_ensamble/#222-tablero-b","text":"Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero B 2 Tornillos de cabeza redonda M3x10mm 2 Tuercas M3 1 M\u00f3dulo rel\u00e9 1 Cable tipo dupont H-H de 3 pines En la Figura 2.2.4 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.4. Tablero B y todos los componentes Ensamblamos el m\u00f3dulo rel\u00e9 en el tablero con los 2 tornillos M3x10mm y las 2 tuercas M3. En la Figura 2.2.5 vemos el aspecto del tablero B en este momento. Figura 2.2.5. Tablero B con los componentes montados Conectamos el cable tipo dupont de 3 pines teniendo la precauci\u00f3n de que queden orientados para que coincidan las letras en cada extremo y pasamos el extremo contrario por la ranura que hay a la derecha del rel\u00e9.","title":"2.2.2. Tablero B"},{"location":"2_2_ensamble/#223-ensamblar-tableros-a-y-b","text":"Para fijar los tableros A y B utilizamos un burl\u00f3n tipo T. El material para este paso lo vemos en la Figura 2.2.6. Figura 2.2.6. Materiales para el ensamblado de los tableros A y B El resultado y la posici\u00f3n del burl\u00f3n lo podemos apreciar en la Figura 2.2.7. Figura 2.2.7. Ensamblado de los tableros A y B","title":"2.2.3. Ensamblar tableros A y B"},{"location":"2_2_ensamble/#224-tablero-c","text":"Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero C 1 Tornillo de cabeza redonda M3x10mm 2 Tornillos de cabeza avellanada M3x10mm 3 Tuercas M3 1 Sensor de gas MQ-2 1 Soporte para 6 pilas o bater\u00edas AA 1 Cable tipo dupont H-H de 4 pines El soporte para pilas va dotado de un conector DC macho de \u00d8_int. 2.1mm y \u00d8_ext. 5.5mm que deja al conjunto listo para alimentar la placa de control. En la Figura 2.2.8 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.8. Tablero C y todos los componentes Fijamos el soporte para pilas al tablero C utilizando los dos tornillos M3x10mm de cabeza avellanada y 2 tuercas M3. Ahora instalamos el m\u00f3dulo sensor de gases MQ-2 en el tablero C utilizando el tornillo M3x10 de cabeza redonda y la tuerca M3 restante. En la Figura 2.2.9 vemos el aspecto del tablero B en este momento. Figura 2.2.9. Tablero C con los componentes montados Conectamos el cable tipo dupont de 4 pines al MQ-2 teniendo la precauci\u00f3n de que queden orientados para que coincidan las letras en cada extremo y pasamos el extremo contrario por la ranura que hay debajo del sensor.","title":"2.2.4. Tablero C"},{"location":"2_2_ensamble/#226-tablero-d","text":"Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero D 1 Tablero 1 4 Tornillos de cabeza redonda M3x12mm 4 Tuercas M3 autoblocantes 2 Tornillos de cabeza redonda M2x12mm 2 Tuercas M2 4 Tornillos autoroscantes M1.2x5mm 1 Tornillo de cabeza redonda M2x5mm 1 Engranaje 1 Servo motor 9g 1 Cruz de montaje En la Figura 2.2.10 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.10. Tablero D y todos los componentes Antes de colocar el servo en su posici\u00f3n debemos proceder a rotarlo 90\u00ba. Para ello vamos a conectar el servo al conjunto de placas tal y como vemos en la Figura 2.2.11. Figura 2.2.11. Servo conectado al pin 10 para rotarlo 90\u00ba Conectamos el servo al pin 10 de la shield V5 y le grabamos el programa que vemos en la Figura 2.2.12. Esta tarea se puede realizar en cualquier otro pin de la placa. La conexi\u00f3n del servo la realizamos teniendo en cuenta los colores vistos al principio del apartado. Figura 2.2.12. Programa para rotar el servo 90\u00ba Una vez que subimos el programa a la placa el servo queda rotado 90\u00ba. Fijamos el servo en su lugar utilizando los 2 tornillos de cabeza redonda M2x12mm y 2 tuercas M2x12. Despu\u00e9s instalamos el tablero 1 en el tablero D utilizando los 4 tornillos de cabeza redonda M3x12mm y las 4 tuercas autoblocantes. En la Figura 2.2.13 vemos el aspecto del tablero B en este momento. Figura 2.2.13. Tablero D con el servo y el tablero 1 montados Fijamos la cruz blanca al engranaje con los 4 tornillos autoroscantes M1.2x5mm tal y como vemos en la Figura 2.2.14. Figura 2.2.14. Fijaci\u00f3n de la cruz del servo al engranaje Montamos el engranaje en el servo motor fij\u00e1ndolo con el tornillo M2x5mm. Pasamos el cable del servo por la ranura y tendremos el panel en el estado que vemos en la Figura 2.2.15. Figura 2.2.15. Tablero D con los componentes montados","title":"2.2.6. Tablero D"},{"location":"2_2_ensamble/#problema-montaje-servo","text":"En la imagen siguiente vemos el problema que se plantea al colocar el engranaje del servo en el mismo. Los dientes apenas coinciden lo que puede originar un funcionamiento err\u00f3neo o peor a\u00fan, un desgaste de los dientes que hagan inservible al engranaje. El problema se detecta cuando se programa el servo y se comprueba que no se mueve de forma correcta. Mal alineamiento de engranajes La soluci\u00f3n que he optado por darle es dise\u00f1ar e imprimir dos peque\u00f1as piezas que act\u00faen a modo de distanciador y que dejen alineado ambos engranajes. En la imagen siguiente vemos las piezas, donde van colocadas y el resultado final una vez puesto todo en su lugar. Buen alineamiento de engranajes Aunque se trata de una pieza muy sencilla de dise\u00f1ar, siguiendo fiel a mi costumbre, pongo en los enlaces el archivo fuente ( posicionador.FCStd ) y el archivo stl ( posicionador-servo.stl ) por si los necesitas.","title":"Problema montaje servo"},{"location":"2_2_ensamble/#226-ensamblar-tableros-c-y-d","text":"Para fijar los tableros C y D utilizamos un burl\u00f3n tipo T. El material para este paso lo vemos en la Figura 2.2.16. Figura 2.2.16. Materiales para el ensamblado de los tableros C y D El resultado y la posici\u00f3n del burl\u00f3n lo podemos apreciar en la Figura 2.2.17. Figura 2.2.17. Ensamblado de los tableros C y D","title":"2.2.6. Ensamblar tableros C y D"},{"location":"2_2_ensamble/#227-tablero-e","text":"Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero E 1 Tornillo de cabeza redonda M3x10mm 1 Tuerca M3 1 LED amarillo 1 Cable tipo dupont H-H de 3 pines En la Figura 2.2.18 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.18. Tablero E y todos los componentes Montamos el LED amarillo en su lugar el tornillo M3x10mm de cabeza redonda y la tuerca M3. En la Figura 2.2.19 vemos el aspecto del tablero B en este momento. Figura 2.2.19. Tablero E con los componentes montados Conectamos el cable tipo dupont de 3 pines al sensor la precauci\u00f3n de orientar el conector de forma correcta.","title":"2.2.7. Tablero E"},{"location":"2_2_ensamble/#228-tablero-h","text":"Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero H 2 Tablero 2 2 Engranajes 8 Tornillos de cabeza redonda M3x6mm 1 Tornillo de cabeza redonda M3x10mm 1 Tuerca M3 2 Tornillos de cabeza redonda M2x12mm 2 Tuercas M2 4 Separadores hexagonales M3x10mm 4 Tornillos autoroscantes M1.2x5mm 1 Tornillo de cabeza redonda M2x5mm 1 Servo motor 9g 1 Pala de montaje 1 Zumbador pasivo 1 Cable tipo dupont H-H de 3 pines 1 Placa de control Keyestudio PLUS 1 Placa Sensor shield En la Figura 2.2.20 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.20. Tablero H y todos los componentes Montamos los 4 separadores en el tablero H sujet\u00e1ndolos con 4 tornillos M3x6mm y fijamos el zumbador pasivo con un tornillo M3x10mm y una tuerca M3, tal y como vemos en la Figura 2.2.21. Figura 2.2.21. Tablero H con separadores y zumbador Rotamos el servo 90\u00ba de la misma forma que hicimos en el apartado \" 2.2.6: Tablero D \" antes de instalarlo en su lugar utilizando dos tornillos M2x12mm y dos tuercas M2. Fijamos la placa de control keyestudio PLUS a los 4 separadores utilizando 4 tornillos M3x6mm. En la Figura 2.2.22 vemos como queda el conjunto una vez dados los pasos anteriores. Figura 2.2.22. Tablero H con placa de control, zumbador y servo Ensamblados las dos piezas 'Tablero 2' y atornillamos la pala de montaje al engranaje tal y como vemos en la Figura 2.2.23. Figura 2.2.23. Ensable de Tablero 2 y pala a engranaje Fijar el engranaje con la cruz de montaje en el servo utilizando un tornillo M2x5mm (incluido con el servo). Ahora instalamos la combinaci\u00f3n de los dos tableros numerados con el 2 y el otro engranaje en el lugar correspondiente del tablero H para que quede algo como lo que vemos en la Figura 2.2.24. Figura 2.2.24. Tablero H con los componentes montados Finalmente conectamos el cable tipo dupont de 3 pines al zumbador teniendo la precauci\u00f3n de orientar el conector de forma correcta y colocamos la placa 'sensor shield' en la placa de control keyestudio PLUS. El conjunto del tablero H tendr\u00e1 el aspecto de la Figura 2.2.25. Figura 2.2.25. Tablero H finalizado","title":"2.2.8. Tablero H"},{"location":"2_2_ensamble/#229-ensamblar-abcde-y-h","text":"Se trata de unir utilizando burlones en T el ensambles A y B, el ensamble C y D y los paneles E y H. El conector de alimentaci\u00f3n de la placa control PLUS debe quedar alineado con el orificio 8 del tablero B, y el conecto USB debe quedar alineado con el orificio 7 del mismo tablero. En la Figura 2.2.26 vemos los materiales que vamos a necesitar para este paso. Figura 2.2.26. Materiales para ensamblar los paneles A,B,C,D,E y H En la Figura 2.2.27 vemos detalles del ensamblaje. Figura 2.2.27. Detalles de ensamblaje de los paneles A,B,C,D,E y H En la figura 2.2.28 vemos el montaje final con los 6 tableros ensamblados. Figura 2.2.28. Ensamble de tableros A,B,C,D,E y H finalizado","title":"2.2.9. Ensamblar A,B,C,D,E y H"},{"location":"2_2_ensamble/#2210-tablero-f","text":"Preparamos los componentes siguientes: Cantidad Designaci\u00f3n Aspecto 1 Tablero F 3 Tornillos de cabeza redonda M3x10mm 3 Tuercas M3 1 Sensor de vapor (Steam Sensor) 1 Sensor fotoc\u00e9lula o LDR 1 M\u00f3dulo motor DC con ventilador 2 Cable tipo dupont H-H de 4 pines 1 Cable tipo dupont H-H de 3 pines En la Figura 2.2.29 vemos el conjunto de materiales desplegado para tenerlo todo a mano para comenzar el montaje. Figura 2.2.29. Tablero F y todos los componentes Fijamos por separado el sensor de vapor, la fotoc\u00e9lula o LDR y el m\u00f3dulo ventilador en la placa F con 3 tornillos de cabeza redonda M3x10mm y 3 tuercas M3, posteriormente colocamos cables tipo dupont de 3 pines y 4 pines. En la Figura 2.2.30 vemos el aspecto del tablero F en este momento. Figura 2.2.30. Tablero F con los componentes montados","title":"2.2.10: Tablero F"},{"location":"2_2_ensamble/#2211-conexionado","text":"Antes de poder finalizar el ansamblado de la smart home necesitamos conectar todos los m\u00f3dulos y sensores a la placa de control a trav\u00e9s de la Sensor Shield V5.2. Vamos a ir viendo paso a paso como hacer esta tarea, en la que debemos prestar especial atenci\u00f3n al sentido de colocaci\u00f3n de los conectores y al n\u00famero de pin que va conectado cada uno. De esta forma tendremos tambi\u00e9n una gu\u00eda de conexiones que nos resultar\u00e1 util cuando iniciemos los retos de programaci\u00f3n.","title":"2.2.11: Conexionado"},{"location":"2_2_ensamble/#por-partes","text":"Seg\u00fan el proceso de montaje seguido ya tendremos conectado un extremo de los cables dupont de 3 \u00f3 4 pines a los pines del sensor o al m\u00f3dulo, ahora toca conectar el otro extremo a la placa Sensor Shield V5.2. Tambi\u00e9n conectaremos los dos servos en este paso. En la tabla siguiente vemos de manera gr\u00e1fica y descriptiva las conexiones de todos los elementos. Sensor - m\u00f3dulo en sensor en shield N\u00ba Esquema Rel\u00e9 LED blanco G - V - S G - V - S G - V - 12 G - V - 13 6 1 Motor DC, m\u00f3dulo ventilador GND - VCC - INA - INB G - V - 7 - 6 15 Bot\u00f3n izquierdo LED amarillo G - V - S G - V - S G - V - 4 G - V - 5 3 12 Zumbador Sensor PIR G - V - S G - V - S G - V - 3 G - V - 2 16 5 Bot\u00f3n derecho Sensor gas MQ-2 G - V - S GND - VCC - D0 - A0 G - V - 8 G - V - 11 - A0 4 10 Sensor de vapor Sensor humedad fotocelula LDR G - V - S G - V - S G - V - S G - V - A3 G - V - A2 G - V - A1 13 - 14 Servo puerta Servo ventana Marr\u00f3n - Rojo - Naranja Marr\u00f3n - Rojo - Naranja G - V - 9 G - V - 10 17 11 Pantalla LCD1602 GND - VCC - SDA - SCL GND - VCC - SDA - SCL (IIC) 2 M\u00f3dulo bluetooth VCC - GND - TXD - RXD 5V - GND - RXD - TXD (COM) -","title":"Por partes"},{"location":"2_2_ensamble/#completo","text":"En la Figura 2.2.31 vemos el esquema de conexionado completo. Figura 2.2.31. Esquema de conexiones A continuaci\u00f3n tenemos la tabla de conexiones expresadas mediante texto. Sensor - m\u00f3dulo en sensor en shield Rel\u00e9 G - V - S G - V - 12 LED blanco G - V - S G - V - 13 Motor DC, m\u00f3dulo ventilador GND - VCC - INA - INB G - V - 7 - 6 Bot\u00f3n izquierdo G - V - S G - V - 4 LED amarillo G - V - S G - V - 5 Zumbador G - V - S G - V - 3 Sensor PIR G - V - S G - V - 2 Bot\u00f3n derecho G - V - S G - V - 8 Sensor gas MQ-2 GND - VCC - D0 - A0 G - V - 11 - A0 Sensor de vapor G - V - S G - V - A3 Sensor humedad G - V - S G - V - A2 Fotocelula LDR G - V - S G - V - A1 Servo puerta Marr\u00f3n - Rojo - Naranja Marr\u00f3n - Rojo - Naranja G - V - 9 Servo ventana Marr\u00f3n - Rojo - Naranja Marr\u00f3n - Rojo - Naranja G - V - 10 Pantalla LCD1602 GND - VCC - SDA - SCL GND - VCC - SDA - SCL (IIC) M\u00f3dulo bluetooth VCC - GND - TXD - RXD 5V - GND - RXD - TXD (COM)","title":"Completo"},{"location":"2_2_ensamble/#detalles","text":"El aspecto de la smart home con todas las conexiones realizadas lo vemos en la Figura 2.2.32, donde se han conectado mediante cables tipo dupont tanto el sensor de humedad como el m\u00f3dulo bluetooth. Este \u00faltimo puede insertarse directamente en la shield pero como vamos a realizar diferentes programaciones de la placa es conveniente tenerlo a mano para poder desconectarlo y conectarlo de forma sencilla. Figura 2.2.32. Smart home con todas las conexiones La conexi\u00f3n del m\u00f3dulo bluetooth se realiza con 4 cables tipo dupont M-H dado que en la shield las conexiones disponibles en el puerto COM son hembra. El orden de conexiones lo vemos en la tabla siguiente: M\u00f3dulo bluetooth Sensor shield V5.2 Descripci\u00f3n VCC 5V Positivo de alimentaci\u00f3n GND GND Negativo de alimentaci\u00f3n TXD RXD Conexi\u00f3n cruzada de Tx con Rx RXD TXD Conexi\u00f3n cruzada de Rx con Tx Como se indica en la tabla los pines de transmisi\u00f3n y recepci\u00f3n de ambas placas deben cruzarse de modo que ambas se 'escuchen' entre si. En la Figura 2.2.33 vemos el tablero F colocado en su lugar y el m\u00f3dulo bluetooth colocado sobre la shield V5.2. Figura 2.2.33. M\u00f3dulo bluetooth y tablero F colocados","title":"Detalles"},{"location":"2_2_ensamble/#2212-ensamblar-tableros-f-y-g","text":"Para fijar el tablero F utilizaremos el material que vemos en la Figura 2.2.34, es decir, el tablero ya montado, dos tornillos de cabeza redonda M3x10mm, dos tuercas y los dos burlones que vemos en la Figura. Figura 2.2.34. Materiales para el ensamblado del tablero F El tablero G solamente requiere colocarlo en su lugar y sujetarlo con dos burlones en T. El resultado, la posici\u00f3n de los burlones para el tablero G y el tablero F colocado lo podemos apreciar en la Figura 2.2.35. Figura 2.2.35. Ensamblado de los tableros F y G","title":"2.2.12: Ensamblar tableros F y G"},{"location":"2_2_ensamble/#2213-ensamblado-del-suelo","text":"Este es el paso final de ensamblado del kit. El material que necesitamos para llevarlo a cabo es el que vemos en la Figura 2.2.36, el tablero del suelo y 6 burlones en T. Figura 2.2.36. Materiales para el ensamblado del tablero del suelo Teniendo especial cuidado de que el ensamble de los tableros 2 y el engranaje de la puerta queden colocados en su lugar, posicionamos el suelo y lo sujetamos con los burlones para obtener el resultado que vemos en la Figura 2.2.37. Figura 2.2.37. Suelo ensamblado En la Figura 2.2.38 vemos el montaje finalizado y listo para empezar a programarlo. Figura 2.2.38. Kit completamente montado","title":"2.2.13: Ensamblado del suelo"},{"location":"BT/","text":"4.1. Bluetooth \u00b6 Bluetooth es una especificaci\u00f3n industrial para Redes Inal\u00e1mbricas de \u00c1rea Personal (WPAN) que posibilita la transmisi\u00f3n de voz y datos entre diferentes dispositivos mediante un enlace por radiofrecuencia en la banda ISM de los 2.4 a 2.485 GHz. Los principales objetivos que se pretenden conseguir con esta norma son: Facilitar las comunicaciones entre equipos m\u00f3viles. Eliminar los cables y conectores entre estos. Ofrecer la posibilidad de crear peque\u00f1as redes inal\u00e1mbricas y facilitar la sincronizaci\u00f3n de datos entre equipos personales. Se denomina Bluetooth al protocolo de comunicaciones dise\u00f1ado especialmente para dispositivos de bajo consumo, que requieren corto alcance de emisi\u00f3n y basados en transceptores (dispositivos que cuentan con transmisor y receptor compartiendo parte de la circuiter\u00eda) de bajo costo. El hardware que compone el dispositivo Bluetooth est\u00e1 compuesto por dos partes: un dispositivo de radio, encargado de modular y transmitir la se\u00f1al. un controlador digital, compuesto por una CPU, un procesador de se\u00f1ales digitales (DSP \u2013 Digital Signal Processor) llamado Link Controller (o controlador de Enlace) y de las interfaces con el dispositivo anfitri\u00f3n. Bluetooth V2 \u00b6 Existe un procedimiento definido que se llama Pairing (o emparejamiento) que vincula a dos dispositivos Bluetooth. Cuando vinculamos dos dispositivos Bluetooth, se inicia un proceso en el que ellos se identifican por nombre y direcci\u00f3n interna y se solicitan la clave PIN para autorizar la conexi\u00f3n. Si el emparejamiento se realiza con \u00e9xito, ambos nodos suelen guardar la identificaci\u00f3n del otro y cuando se encuentran cerca se vuelven a vincular sin necesidad de intervenci\u00f3n manual. Para manejar los m\u00f3dulos Bluetooth se utilizan los comandos Hayes o AT, de los que puedes encontrar informaci\u00f3n en este enlace y a continuaci\u00f3n damos algunos b\u00e1sicos: AT+VERSION: Versi\u00f3n del Firmware. AT+NAMEXXX: Para establecer el nombre que queremos presentar cuando otro dispositivo nos busque. AT+PINXXXX: permite establecer el n\u00famero de identificaci\u00f3n personal, que se requerir\u00e1 para establecer la vinculaci\u00f3n. AT+BAUDX: Permite fijar la velocidad de comunicaci\u00f3n entre el modulo y la consola seg\u00fan los siguientes pares: 1 -> 1200 bps | -5 -> 19200 bps 2 -> 2400 bps | -6 -> 38400 bps 3 -> 4800 bps | -7 -> 57600 bps 4 -> 9600 bps | -8 -> 115200 bps La velocidad por defecto es la de 9600 bps. Los m\u00f3dulos mas conocidos son el HC-05 y HC-06 que son Bluetooth V2 y cuyo aspecto podemos ver en la imagen siguiente: Figura 4.1.1. M\u00f3dulos HC-05 y HC-06 Con esto finalizamos el breve repaso a los m\u00f3dulo cl\u00e1sicos Bluetooth V2 y ahora vamos a describir brevemente los m\u00f3dulo Bluetooth 4.0 o low energy. Bluetooth 4.0 o Low Energy \u00b6 B\u00e1sicamente se trata de un nuevo protocolo dise\u00f1ado para reducir en todo lo posible el gran consumo de energ\u00eda de sus predecesores. Generalmente se le conoce como BLE (iniciales de Bluetooth Low Energy) o Bluetooth LE y tienen un consumo t\u00edpico que podemos cifrar entre los 10 y 15 mA. Otra de sus principales novedades radica en que este m\u00f3dulo si es utilizables con dispositivos iOS. El BLE es un subconjunto del est\u00e1ndar Bluetooth v4.0 que dispone de una pila de protocolos en referencia a la capa OSI (en ingl\u00e9s, Open Systems Interconnection) completamente nueva y orientada a conexiones sencillas en aplicaciones de muy baja potencia que suelen funcionar con pilas o bater\u00edas. La pila de protocolos para Bluetooth Low Energy sigue la estructura definida en la Figura 4.1.2. Figura 4.1.2. Pila de protocolos para BLE En la capa f\u00edsica (physical layer) se implementa toda la circuiteria de comunicaciones. La tecnolog\u00eda BLE puede usar hasta 40 canales de 2MHz en la banda ISM. El est\u00e1ndar emplea la t\u00e9cnica \u201cfrequency hopping\u201d o \u201csaltos en frecuencia\u201d, siguiendo una secuencia de saltos pseudo-aleatorios entre los canales frecuenciales mencionados que ofrece un alto grado de robustez frente a interferencias. La capa de enlace (link layer), se encarga de gestionar caracter\u00edsticas como los requerimientos temporales del est\u00e1ndar, chequeo de mensajes y reenv\u00edo de mensajes err\u00f3neos recibidos, gesti\u00f3n, filtrado de direcciones etc. Adem\u00e1s ofrece la definici\u00f3n de roles (Advertiser, Scanner, Master and Slave) que permiten identificar de forma l\u00f3gica el rol de cada dispositivo en el proceso de comunicaci\u00f3n. El nivel LL es del mismo modo responsable de procesos de control como el cambio de par\u00e1metros de la conexi\u00f3n o la encriptaci\u00f3n. el Host Controller o HCI es un protocolo est\u00e1ndar que permite que la comunicaci\u00f3n entre un host y un controlador se lleve a cabo a trav\u00e9s de un interfaz serie. A modo de ejemplo, en la mayor\u00eda de smartphones u ordenadores el host y la aplicaci\u00f3n corren en la CPU principal mientras que el controlador est\u00e1 situado en hardware espec\u00edfico y separado, conectado mediante UART o USB. El est\u00e1ndar Bluetooth define HCI como el conjunto de comandos y eventos para la interacci\u00f3n de ambas partes (host y controlador). La capa L2CAP (Logic Link Control and Adaptation Protocol), se responsabiliza de dos tareas fundamentales en un proceso de comunicaci\u00f3n. En primer lugar, el proceso de multiplexaci\u00f3n, es decir, la capacidad de dar formato a mensajes provenientes de las capas OSI superiores y encapsularlos en paquetes est\u00e1ndar BLE as\u00ed como el proceso inverso. Para BLE, la capa L2CAP es la encargada de dar acceso y soporte a los dos protocolos fundamentales. Por un lado, ATT (Attribute Protocol), un protocolo basado en atributos presentados por dispositivo, con arquitectura cliente-servidor, que permite el intercambio de informaci\u00f3n. Por otro lado, SMP (Security Manager Protocol), protocolo que proporciona un framework para generar y distribuir claves de seguridad entre dos dispositivos. En el nivel m\u00e1s alto de la capa de protocolos, encontraremos de forma paralela las capas GAP y GATT. Esta primera, GAP (Generic Acces Profile), permite que un dispositivo sea visible hacia el resto de dispositivos y adem\u00e1s determina como puede interactuar un dispositivo entre otro. Establece distintas normas y conceptos para estandarizar las operaciones de m\u00e1s bajo nivel como: Roles de interacci\u00f3n Modos de operaci\u00f3n y transici\u00f3n entre ellos Procedimientos para establecimiento de comunicaci\u00f3n Modos de seguridad y procedimientos Al otro lado, GATT (Generic Attribute Profile), que define como dos dispositivos BLE transfieren informaci\u00f3n. Este proceso tiene lugar cuando dos dispositivos han superado la fase de establecimiento de comunicaci\u00f3n (controlada por GAP) y comienza la transferencia de informaci\u00f3n pudiendo ser de forma bidireccional. El kit Smart home viene equipado con un m\u00f3dulo Bluetooth HM-10, que es maestro-esclavo. Cuando se usa como host, puede enviar comandos al esclavo de forma activa; cuando se usa como Esclavo, solo puede recibir comandos del host. En nuestro caso usaremos por defecto el m\u00f3dulo Bluetooth HM-10 como Esclavo y el tel\u00e9fono Maestro. Comandos AT en BLE \u00b6 Para enviar comandos AT vamos a utilizar una placa tipo Arduino c\u00f3mo interfaz serie y la consola de ArduinoBlocks para el envio de comandos. Tambi\u00e9n se puede utilizar un convertidor USB a TTL para establecer las comunicaciones. Las conexiones que hay que hacer entre el Arduino y el Bluetooth HM-10 son las siguientes: VCC a 5V GND a GND TX a TX (no se cruzan las conexiones) RX a RX (no se cruzan las conexiones) No es necesario que la placa tenga ning\u00fan c\u00f3digo subido y por supuesto no debe tener ninguno que utilice la comunicaci\u00f3n serie. Una vez realizadas las conexiones abrimos la consola y establecemos 9600 baudios y NL + LF y comprobamos si est\u00e1 funcionando enviando el comando AT al que el m\u00f3dulo debe responder con un OK. A continuaci\u00f3n tenemos una tabla con un listado de comandos AT que se pueden enviar al Bluetooth HM10. Comando AT Efecto AT Compruebe si el terminal de comando funciona normalmente. AT+RESET Reinicio del software. AT+VERSION Obtener la versi\u00f3n de firmware, bluetooth, HCI y LMP. AT+HELP Lista de todos los comandos. AT+NAME Obtener / establecer el nombre del dispositivo local. AT+PIN Obtener / establecer el c\u00f3digo pin para el emparejamiento. AT+PASS Obtener / establecer el c\u00f3digo pin para el emparejamiento. AT+BAUD Obtener / establecer velocidad en baudios. AT+LADDR Obtener la direcci\u00f3n bluetooth local. AT+ADDR Obtener la direcci\u00f3n bluetooth local. AT+DEFAULT Restaurar valores predeterminados de f\u00e1brica. AT+STATE Obtener el estado actual. AT+PWRM Obtener / Establecer modo de encendido (bajo consumo). AT+POWE Obtener / establecer la potencia de transmisi\u00f3n de RF. AT+SLEEP Modo de sue\u00f1o. AT+ROLE Obtener / establecer el rol actual. AT+PARI Obtener / establecer el bit de paridad UART. AT+STOP Obtener / establecer el bit de parada de UART. AT+START El sistema comienza a funcionar. AT+IMME El sistema espera el comando cuando se enciende. M\u00f3dulo HM-10 Smart home \u00b6 Los principales par\u00e1metros del m\u00f3dulo son: Pin BRK . Es un pin de entrada que responde a un pulso de menos de 100 ms para activas las siguientes funciones: Cuando el m\u00f3dulo est\u00e1 en modo sleep se pone en estado normal. Cuando el estado es conectado, el m\u00f3dulo activa la desconexi\u00f3n. Cuando est\u00e1 en modo espera, el m\u00f3dulo vuelve a su estado inicial. Pin RXD . Entrada de datos serie. Pin TXD . Salida de datos serie. Pin GND . Masa de alimentaci\u00f3n. Pin VCC . Polo positivo de alimentaci\u00f3n a 5V. Pin STATE . Como pin de salida muestra el estado de trabajo del m\u00f3dulo Protocolo Bluetooth: Especificaci\u00f3n Bluetooth V4.0 BLE Sin l\u00edmite de bytes en el puerto serie Transceptor En un entorno abierto, realice una comunicaci\u00f3n de ultra distancia de 100 m con iphone4s Protocolo USB: USB V2.0 Frecuencia de trabajo: banda ISM de 2,4 GHz M\u00e9todo de modulaci\u00f3n: GFSK (clave de desplazamiento de frecuencia gaussiana) Potencia de transmisi\u00f3n: -23dbm, -6dbm, 0dbm, 6dbm, se puede modificar mediante el comando AT. Sensibilidad: \u2264-84dBm a 0,1% BER Tasa de transmisi\u00f3n: As\u00edncrona: 6K bytes; S\u00edncrono: 6k Bytes Caracter\u00edstica de seguridad: Autenticaci\u00f3n y encriptaci\u00f3n Servicio de soporte: UUID central y perif\u00e9rico FFE0, FFE1 Consumo de energ\u00eda: modo de reposo autom\u00e1tico, corriente en espera 400uA~800uA, 8,5 mA durante la transmisi\u00f3n. Fuente de alimentaci\u00f3n: 5V CC Temperatura de trabajo: \u20135 a +65 Cent\u00edgrados","title":"4.1. Bluetooth"},{"location":"BT/#41-bluetooth","text":"Bluetooth es una especificaci\u00f3n industrial para Redes Inal\u00e1mbricas de \u00c1rea Personal (WPAN) que posibilita la transmisi\u00f3n de voz y datos entre diferentes dispositivos mediante un enlace por radiofrecuencia en la banda ISM de los 2.4 a 2.485 GHz. Los principales objetivos que se pretenden conseguir con esta norma son: Facilitar las comunicaciones entre equipos m\u00f3viles. Eliminar los cables y conectores entre estos. Ofrecer la posibilidad de crear peque\u00f1as redes inal\u00e1mbricas y facilitar la sincronizaci\u00f3n de datos entre equipos personales. Se denomina Bluetooth al protocolo de comunicaciones dise\u00f1ado especialmente para dispositivos de bajo consumo, que requieren corto alcance de emisi\u00f3n y basados en transceptores (dispositivos que cuentan con transmisor y receptor compartiendo parte de la circuiter\u00eda) de bajo costo. El hardware que compone el dispositivo Bluetooth est\u00e1 compuesto por dos partes: un dispositivo de radio, encargado de modular y transmitir la se\u00f1al. un controlador digital, compuesto por una CPU, un procesador de se\u00f1ales digitales (DSP \u2013 Digital Signal Processor) llamado Link Controller (o controlador de Enlace) y de las interfaces con el dispositivo anfitri\u00f3n.","title":"4.1. Bluetooth"},{"location":"BT/#bluetooth-v2","text":"Existe un procedimiento definido que se llama Pairing (o emparejamiento) que vincula a dos dispositivos Bluetooth. Cuando vinculamos dos dispositivos Bluetooth, se inicia un proceso en el que ellos se identifican por nombre y direcci\u00f3n interna y se solicitan la clave PIN para autorizar la conexi\u00f3n. Si el emparejamiento se realiza con \u00e9xito, ambos nodos suelen guardar la identificaci\u00f3n del otro y cuando se encuentran cerca se vuelven a vincular sin necesidad de intervenci\u00f3n manual. Para manejar los m\u00f3dulos Bluetooth se utilizan los comandos Hayes o AT, de los que puedes encontrar informaci\u00f3n en este enlace y a continuaci\u00f3n damos algunos b\u00e1sicos: AT+VERSION: Versi\u00f3n del Firmware. AT+NAMEXXX: Para establecer el nombre que queremos presentar cuando otro dispositivo nos busque. AT+PINXXXX: permite establecer el n\u00famero de identificaci\u00f3n personal, que se requerir\u00e1 para establecer la vinculaci\u00f3n. AT+BAUDX: Permite fijar la velocidad de comunicaci\u00f3n entre el modulo y la consola seg\u00fan los siguientes pares: 1 -> 1200 bps | -5 -> 19200 bps 2 -> 2400 bps | -6 -> 38400 bps 3 -> 4800 bps | -7 -> 57600 bps 4 -> 9600 bps | -8 -> 115200 bps La velocidad por defecto es la de 9600 bps. Los m\u00f3dulos mas conocidos son el HC-05 y HC-06 que son Bluetooth V2 y cuyo aspecto podemos ver en la imagen siguiente: Figura 4.1.1. M\u00f3dulos HC-05 y HC-06 Con esto finalizamos el breve repaso a los m\u00f3dulo cl\u00e1sicos Bluetooth V2 y ahora vamos a describir brevemente los m\u00f3dulo Bluetooth 4.0 o low energy.","title":"Bluetooth V2"},{"location":"BT/#bluetooth-40-o-low-energy","text":"B\u00e1sicamente se trata de un nuevo protocolo dise\u00f1ado para reducir en todo lo posible el gran consumo de energ\u00eda de sus predecesores. Generalmente se le conoce como BLE (iniciales de Bluetooth Low Energy) o Bluetooth LE y tienen un consumo t\u00edpico que podemos cifrar entre los 10 y 15 mA. Otra de sus principales novedades radica en que este m\u00f3dulo si es utilizables con dispositivos iOS. El BLE es un subconjunto del est\u00e1ndar Bluetooth v4.0 que dispone de una pila de protocolos en referencia a la capa OSI (en ingl\u00e9s, Open Systems Interconnection) completamente nueva y orientada a conexiones sencillas en aplicaciones de muy baja potencia que suelen funcionar con pilas o bater\u00edas. La pila de protocolos para Bluetooth Low Energy sigue la estructura definida en la Figura 4.1.2. Figura 4.1.2. Pila de protocolos para BLE En la capa f\u00edsica (physical layer) se implementa toda la circuiteria de comunicaciones. La tecnolog\u00eda BLE puede usar hasta 40 canales de 2MHz en la banda ISM. El est\u00e1ndar emplea la t\u00e9cnica \u201cfrequency hopping\u201d o \u201csaltos en frecuencia\u201d, siguiendo una secuencia de saltos pseudo-aleatorios entre los canales frecuenciales mencionados que ofrece un alto grado de robustez frente a interferencias. La capa de enlace (link layer), se encarga de gestionar caracter\u00edsticas como los requerimientos temporales del est\u00e1ndar, chequeo de mensajes y reenv\u00edo de mensajes err\u00f3neos recibidos, gesti\u00f3n, filtrado de direcciones etc. Adem\u00e1s ofrece la definici\u00f3n de roles (Advertiser, Scanner, Master and Slave) que permiten identificar de forma l\u00f3gica el rol de cada dispositivo en el proceso de comunicaci\u00f3n. El nivel LL es del mismo modo responsable de procesos de control como el cambio de par\u00e1metros de la conexi\u00f3n o la encriptaci\u00f3n. el Host Controller o HCI es un protocolo est\u00e1ndar que permite que la comunicaci\u00f3n entre un host y un controlador se lleve a cabo a trav\u00e9s de un interfaz serie. A modo de ejemplo, en la mayor\u00eda de smartphones u ordenadores el host y la aplicaci\u00f3n corren en la CPU principal mientras que el controlador est\u00e1 situado en hardware espec\u00edfico y separado, conectado mediante UART o USB. El est\u00e1ndar Bluetooth define HCI como el conjunto de comandos y eventos para la interacci\u00f3n de ambas partes (host y controlador). La capa L2CAP (Logic Link Control and Adaptation Protocol), se responsabiliza de dos tareas fundamentales en un proceso de comunicaci\u00f3n. En primer lugar, el proceso de multiplexaci\u00f3n, es decir, la capacidad de dar formato a mensajes provenientes de las capas OSI superiores y encapsularlos en paquetes est\u00e1ndar BLE as\u00ed como el proceso inverso. Para BLE, la capa L2CAP es la encargada de dar acceso y soporte a los dos protocolos fundamentales. Por un lado, ATT (Attribute Protocol), un protocolo basado en atributos presentados por dispositivo, con arquitectura cliente-servidor, que permite el intercambio de informaci\u00f3n. Por otro lado, SMP (Security Manager Protocol), protocolo que proporciona un framework para generar y distribuir claves de seguridad entre dos dispositivos. En el nivel m\u00e1s alto de la capa de protocolos, encontraremos de forma paralela las capas GAP y GATT. Esta primera, GAP (Generic Acces Profile), permite que un dispositivo sea visible hacia el resto de dispositivos y adem\u00e1s determina como puede interactuar un dispositivo entre otro. Establece distintas normas y conceptos para estandarizar las operaciones de m\u00e1s bajo nivel como: Roles de interacci\u00f3n Modos de operaci\u00f3n y transici\u00f3n entre ellos Procedimientos para establecimiento de comunicaci\u00f3n Modos de seguridad y procedimientos Al otro lado, GATT (Generic Attribute Profile), que define como dos dispositivos BLE transfieren informaci\u00f3n. Este proceso tiene lugar cuando dos dispositivos han superado la fase de establecimiento de comunicaci\u00f3n (controlada por GAP) y comienza la transferencia de informaci\u00f3n pudiendo ser de forma bidireccional. El kit Smart home viene equipado con un m\u00f3dulo Bluetooth HM-10, que es maestro-esclavo. Cuando se usa como host, puede enviar comandos al esclavo de forma activa; cuando se usa como Esclavo, solo puede recibir comandos del host. En nuestro caso usaremos por defecto el m\u00f3dulo Bluetooth HM-10 como Esclavo y el tel\u00e9fono Maestro.","title":"Bluetooth 4.0 o Low Energy"},{"location":"BT/#comandos-at-en-ble","text":"Para enviar comandos AT vamos a utilizar una placa tipo Arduino c\u00f3mo interfaz serie y la consola de ArduinoBlocks para el envio de comandos. Tambi\u00e9n se puede utilizar un convertidor USB a TTL para establecer las comunicaciones. Las conexiones que hay que hacer entre el Arduino y el Bluetooth HM-10 son las siguientes: VCC a 5V GND a GND TX a TX (no se cruzan las conexiones) RX a RX (no se cruzan las conexiones) No es necesario que la placa tenga ning\u00fan c\u00f3digo subido y por supuesto no debe tener ninguno que utilice la comunicaci\u00f3n serie. Una vez realizadas las conexiones abrimos la consola y establecemos 9600 baudios y NL + LF y comprobamos si est\u00e1 funcionando enviando el comando AT al que el m\u00f3dulo debe responder con un OK. A continuaci\u00f3n tenemos una tabla con un listado de comandos AT que se pueden enviar al Bluetooth HM10. Comando AT Efecto AT Compruebe si el terminal de comando funciona normalmente. AT+RESET Reinicio del software. AT+VERSION Obtener la versi\u00f3n de firmware, bluetooth, HCI y LMP. AT+HELP Lista de todos los comandos. AT+NAME Obtener / establecer el nombre del dispositivo local. AT+PIN Obtener / establecer el c\u00f3digo pin para el emparejamiento. AT+PASS Obtener / establecer el c\u00f3digo pin para el emparejamiento. AT+BAUD Obtener / establecer velocidad en baudios. AT+LADDR Obtener la direcci\u00f3n bluetooth local. AT+ADDR Obtener la direcci\u00f3n bluetooth local. AT+DEFAULT Restaurar valores predeterminados de f\u00e1brica. AT+STATE Obtener el estado actual. AT+PWRM Obtener / Establecer modo de encendido (bajo consumo). AT+POWE Obtener / establecer la potencia de transmisi\u00f3n de RF. AT+SLEEP Modo de sue\u00f1o. AT+ROLE Obtener / establecer el rol actual. AT+PARI Obtener / establecer el bit de paridad UART. AT+STOP Obtener / establecer el bit de parada de UART. AT+START El sistema comienza a funcionar. AT+IMME El sistema espera el comando cuando se enciende.","title":"Comandos AT en BLE"},{"location":"BT/#modulo-hm-10-smart-home","text":"Los principales par\u00e1metros del m\u00f3dulo son: Pin BRK . Es un pin de entrada que responde a un pulso de menos de 100 ms para activas las siguientes funciones: Cuando el m\u00f3dulo est\u00e1 en modo sleep se pone en estado normal. Cuando el estado es conectado, el m\u00f3dulo activa la desconexi\u00f3n. Cuando est\u00e1 en modo espera, el m\u00f3dulo vuelve a su estado inicial. Pin RXD . Entrada de datos serie. Pin TXD . Salida de datos serie. Pin GND . Masa de alimentaci\u00f3n. Pin VCC . Polo positivo de alimentaci\u00f3n a 5V. Pin STATE . Como pin de salida muestra el estado de trabajo del m\u00f3dulo Protocolo Bluetooth: Especificaci\u00f3n Bluetooth V4.0 BLE Sin l\u00edmite de bytes en el puerto serie Transceptor En un entorno abierto, realice una comunicaci\u00f3n de ultra distancia de 100 m con iphone4s Protocolo USB: USB V2.0 Frecuencia de trabajo: banda ISM de 2,4 GHz M\u00e9todo de modulaci\u00f3n: GFSK (clave de desplazamiento de frecuencia gaussiana) Potencia de transmisi\u00f3n: -23dbm, -6dbm, 0dbm, 6dbm, se puede modificar mediante el comando AT. Sensibilidad: \u2264-84dBm a 0,1% BER Tasa de transmisi\u00f3n: As\u00edncrona: 6K bytes; S\u00edncrono: 6k Bytes Caracter\u00edstica de seguridad: Autenticaci\u00f3n y encriptaci\u00f3n Servicio de soporte: UUID central y perif\u00e9rico FFE0, FFE1 Consumo de energ\u00eda: modo de reposo autom\u00e1tico, corriente en espera 400uA~800uA, 8,5 mA durante la transmisi\u00f3n. Fuente de alimentaci\u00f3n: 5V CC Temperatura de trabajo: \u20135 a +65 Cent\u00edgrados","title":"M\u00f3dulo HM-10 Smart home"},{"location":"LCD/","text":"3.12. A11-La LCD de 2x16 \u00b6 Las comunicaciones I2C \u00b6 Dado que la placa PLUS dispone de un puerto de expansi\u00f3n I2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado) vamos a explicar un poco en que consiste este sistema de conexionado. Bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la Figura 3.12.1 vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Figura 3.12.1. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores, o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el master prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en una UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Figura 3.12.2. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo. La LCD 1602 \u00b6 Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la Figura 3.12.3. Figura 3.12.3. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa UNO para su control. En la Figura 3.12.4 se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo: 4 bits para datos y dos se\u00f1ales de control: En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Figura 3.12.4. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar las que tienen el aspecto que vemos en la Figura 3.12.5. Figura 3.12.5. LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la Figura 3.12.5 no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste. Esta pantalla requiere cuatro cables para establecer las conexiones, un cable para SDA (datos), otro para SCL (reloj) y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo, que en el caso de la que incorpora el kit Smart home es la 0x27, pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado y se muestra el sistema de distribuci\u00f3n de filas y columnas. Figura 3.12.6. Bloques para imprimir en un par fila-columna Escanear dispositivos I2C \u00b6 Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la Figura 3.12.7. Figura 3.12.7. Menu I2C Un sencillo programa como el de la Figura 3.12.9 nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Smart-home-detectar-IIC . No se requiere ning\u00fan bloque para enviar datos a la consola porque lo hace el propio bloque de escaneo. Figura 3.12.8. Smart-home-detectar-IIC Si conectamos la consola el resultado de tener la Smart home conectada es el de la Figura 3.12.9. Figura 3.12.9. Consola para el programa Smart-home-detectar-IIC Cambiar la direcci\u00f3n f\u00edsica de un dispositivo I2C \u00b6 Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la Figura 3.12.10. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Figura 3.12.10. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la Figura 3.12.11 se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Figura 3.12.11. Direcci\u00f3n 0x26 Definici\u00f3n de s\u00edmbolos en la LCD \u00b6 Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la Figura 3.12.12. Figura 3.12.12. Ejemplo de s\u00edmbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque. Multitarea \u00b6 Este apartado se extrae de ArduinoBlocks - FreeBook disponible en Free Book (online & updated) . ArduinoBlocks nos permite utilizar una capa para implementar un sistema multitarea avanzado basado en FreeRTOS (del ingl\u00e9s Real Time Operating System), que es un sistema operativo de tiempo real kernel para dispositivos embebidos para plataformas de microcontrolador que se distribuye bajo licencia MIT. Este sistema permite crear tareas que se ejecutar\u00e1n de forma paralela (virtualmente). En microcontroladores modestos como el Arduino UNO, Nano o incluso MEGA la multitarea con FreeRTOS es bastante limitada y consume gran parte de los recursos de nuestro Arduino, en caso de necesitar de un sistema multitarea m\u00e1s potente podemos optar por usarlo en placas basadas en ESP8266 o ESP32 con mucha m\u00e1s potencia y recursos (especialmente el ESP32 con doble n\u00facleo y gran potencia de procesamiento y memoria interna) Los sistemas software de multitarea utilizan un planificador o scheduler que se encarga de repartir el tiempo de procesamiento entre las distintas tareas, de forma que a cada una le toca un tiempo de microcontrolador para ejecutar un poquito de su parte de programa. En las web de freeRTOS , en su entrada de men\u00fa Kerne podemos encontrar los conceptos b\u00e1sicos de multitarea y de programaci\u00f3n que vamos a extractar seguidamente. Conceptos b\u00e1sicos de multitarea \u00b6 Un procesador convencional como el de Arduino UNO solo puede ejecutar una tarea a la vez, pero al cambiar r\u00e1pidamente entre tareas, un sistema operativo multitarea puede hacer que parezca que cada tarea se ejecuta simult\u00e1neamente. Esto es lo que se representa en el diagrama de la Figura 3.12.13 que muestra el patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo. Los nombres de las tareas est\u00e1n codificados por colores y escritos a la izquierda. El tiempo se mueve de izquierda a derecha y las l\u00edneas de colores muestran qu\u00e9 tarea se est\u00e1 ejecutando en un momento determinado. El diagrama superior demuestra el patr\u00f3n de ejecuci\u00f3n concurrente percibido, y el inferior el patr\u00f3n de ejecuci\u00f3n multitarea real. Figura 3.12.13. Patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo Programaci\u00f3n \u00b6 El programador es quien debe decidir qu\u00e9 tarea debe ejecutarse en un momento determinado. El kernel o n\u00facleo puede suspender y luego reanudar una tarea muchas veces durante el tiempo de vida de la tarea. Adem\u00e1s de ser suspendida involuntariamente por el n\u00facleo o kernel, una tarea puede optar por suspenderse a s\u00ed misma. Har\u00e1 esto si desea retrasar ( dormir ) por un per\u00edodo fijo o esperar ( bloquear ) a que un recurso (por ejemplo, un puerto serie) est\u00e9 disponible, o que ocurra un evento (por ejemplo, presionar una pulsador). Una tarea bloqueada o inactiva no se puede ejecutar y no se le asignar\u00e1 ning\u00fan tiempo de procesamiento. En la Figura 3.12.14 vemos un posible diagrama de ejecuci\u00f3n de tres tareas analizado punto por punto en distintos instantes de tiempo. En los c\u00edculos se representan los instantes de tiempo t1 a t10. Figura 3.12.14. Diagrama de ejecuci\u00f3n de tres tareas en el tiempo t1: la tarea 1 se est\u00e1 ejecutando. t2: en el kernel se suspende, o mejor dicho se intercambia, la tarea 1 . t3: se reanuda la tarea 2 . t4: mientras se ejecuta la tarea 2 el procesador bloquea el puerto serie para su acceso exclusivo. t5: el kernel suspende la tarea 2 . t6: el kernel reanuda la tarea 3 . t1: la tarea 3 intenta acceder al puerto serie y lo encuentra bloqueado por lo que no puede continuar y se suspende. t8: el kernel reanuda la tarea 1 . t9: al ejecutarse de nuevo la tarea 2 se desbloquea el puerto serie. t10: la tarea 3 ahora si puede acceder al puerto serie y se ejecuta al completo Planificadores \u00b6 Los planificadores de multitarea permiten asignar a cada tarea una prioridad, para as\u00ed darle preferencia a las tareas m\u00e1s cr\u00edticas o que necesitan m\u00e1s tiempo de procesamiento. Si creamos muchas tareas con \u201calta\u201d prioridad puede que afectemos a las dem\u00e1s dejando poco tiempo de procesamiento para ellas. En la Figura 3.12.15 vemos un esquema de varias tareas con distintas prioridades, variando as\u00ed su tiempo de microprocesador asignado. Figura 3.12.15. Distintas prioridades en tres tareas Cada tarea tiene su propio espacio de memoria, por lo que crear demasiadas tareas tambi\u00e9n puede dejarnos el procesador sin memoria. Si la memoria asignada a las tareas tampoco es suficiente para almacenar los datos se podr\u00eda reiniciar de forma inesperada el Arduino, o funcionar incorrectamente, es decir que como siempre, hay que ser consciente de los limitados recursos de los que disponemos. Sem\u00e1foros \u00b6 Con la introducci\u00f3n te\u00f3rica a la multitarea vista, debemos hacernos otra pregunta: \u00bfQu\u00e9 pasa si una tarea accede a un recurso o variable, y el sistema multitarea le da el control a otra tarea y por tanto ese proceso falla o quiz\u00e1s otra tarea acceda al mismo recurso y se solapen? Para ese problema de convivencia entre tareas se inventaron los \u201csem\u00e1foros\u201d, en concreto el que m\u00e1s nos interesa es el sem\u00e1foro \u201cmutex\u201d o de exclusi\u00f3n mutua, que permite que bloqueemos el sistema multitarea, hagamos lo que tengamos que hacer cr\u00edtico, y luego liberemos el control. Por supuesto estas tareas cr\u00edticas deben ser lo m\u00e1s cortas y at\u00f3micas posibles: una escritura cr\u00edtica en una variable, un env\u00edo de un dato, una actualizaci\u00f3n de una pantalla LCD,... siempre cosas simples. Los sem\u00e1foros debemos usarlos en casos que tengamos claro que se pueden crear conflictos, pues su abuso puede hacer que el sistema multitarea empiece a fallar. En la Figura 3.12.16 vemos el esquema de acceso a un recurso desde dos tareas diferentes. Figura 3.12.16. Esquema de acceso a un mismo recurso por parte de 2 tareas diferentes Bloques esperar \u00b6 \u00bfQu\u00e9 pasa con los bloques tipo \u201cesperar\u201d que estaban tan prohibidos en la programaci\u00f3n de Arduino cuando quer\u00edamos simular una multitarea antes de tener estos bloques? Pues seguimos teni\u00e9ndoles bastante tirria. Aunque en teor\u00eda podr\u00edamos usarlos, un bloque esperar hace pensar al microcontrolador que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed, por lo que el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! Tenemos una soluci\u00f3n, tenemos un nuevo bloque de esperar \u201ctask friendly\u201d que en lugar de esperar sin hacer nada le dice al sistema: \u00a1voy a estar un rato sin hacer nada, permite ejecutar otras tareas mientras y luego vuelves! \u2026.Mucho m\u00e1s \u201cfriendly\u201d, claro que s\u00ed. Bloques \u00b6 Con toda esta informaci\u00f3n pasamos a ver los bloques disponibles para poner todo \u00e9sto en marcha. Bloque Descripci\u00f3n Permite crear una nueva tarea con su bloque de \u201cinicializar\u201d y su \u201cbucle\u201d al igual que la tarea original de Arduino. Debemos asignar una prioridad a cada tarea, por defecto dejar\u00eda todas a \u201cbaja\u201d y luego ir\u00eda ajustando si hace falta. Para gestionar mejor las prioridades, es recomendable en algunos casos no utilizar el \u201cinicializar\u201d y \u201cbucle\u201d propio de Arduino que suele tener preferencia sobre todas estas tareas y es m\u00e1s dif\u00edcil de equilibrar las prioridades. El bloque esperar \u00f3ptimo para tareas, pues deja funcionar al resto de tareas de forma m\u00e1s \u00f3ptima mientras se espera en \u00e9sta. Este bloque tiene menos precisi\u00f3n que el bloque \u201cesperar\u201d original, si necesitamos hacer esperas muy precisas (o de menos de 20 ms) debemos usar el \u201cesperar\u201d tradicional. Pero nos servir\u00e1 en la mayor\u00eda de casos. Si tenemos que hacer alguna acci\u00f3n cr\u00edtica que no queremos que sea interrumpida internamente por el planificador del sistema multitarea podemos poner este bloque y dentro los bloques cr\u00edticos. (no utilizar si no es estrictamente necesario) Cada tarea tiene su propio espacio de memoria reservado, esta es la cantidad por defecto para las tareas (192 bytes), si necesitamos ajustarla podemos utilizar este bloque en el \u201cinicializar\u201d principal y se ajustar\u00e1 para todas las tareas. Un mal ajuste puede provocar reinicios del microcontrolador o mal funcionamiento. Las tareas en principio, igual que el bucle de Arduino, est\u00e1n pensadas para ejecutarse de forma indefinida, si en un caso una tarea deja de ser necesaria la forma de terminarla es con este bloque que parar\u00e1 la ejecuci\u00f3n y liberar\u00e1 la memoria de la tarea en la que se ejecuta. Actividades \u00b6 Actividad A11_1 \u00b6 En esta actividad enviaremos un texto a la LCD. El programa final lo tenemos disponible en el enlace Smart-home-A11_1 . Figura 3.2.17. Soluci\u00f3n A11_1 Actividad A11_2 \u00b6 En esta actividad enviaremos a la LCD el valor le\u00eddo por la LDR y el nombre de la canci\u00f3n que suena de forma simult\u00e1nea como primera tarea. Una segunda tarea es reproducir distintas canciones y actualizar el nombre de la variable. El programa final lo tenemos disponible en el enlace Smart-home-A11_2 . Figura 3.2.18. Soluci\u00f3n A11_2","title":"3.12. A11-La LCD de 2x16"},{"location":"LCD/#312-a11-la-lcd-de-2x16","text":"","title":"3.12. A11-La LCD de 2x16"},{"location":"LCD/#las-comunicaciones-i2c","text":"Dado que la placa PLUS dispone de un puerto de expansi\u00f3n I2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado) vamos a explicar un poco en que consiste este sistema de conexionado. Bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la Figura 3.12.1 vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Figura 3.12.1. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores, o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el master prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en una UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Figura 3.12.2. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.","title":"Las comunicaciones I2C"},{"location":"LCD/#la-lcd-1602","text":"Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la Figura 3.12.3. Figura 3.12.3. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa UNO para su control. En la Figura 3.12.4 se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo: 4 bits para datos y dos se\u00f1ales de control: En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Figura 3.12.4. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar las que tienen el aspecto que vemos en la Figura 3.12.5. Figura 3.12.5. LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la Figura 3.12.5 no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste. Esta pantalla requiere cuatro cables para establecer las conexiones, un cable para SDA (datos), otro para SCL (reloj) y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo, que en el caso de la que incorpora el kit Smart home es la 0x27, pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado y se muestra el sistema de distribuci\u00f3n de filas y columnas. Figura 3.12.6. Bloques para imprimir en un par fila-columna","title":"La LCD 1602"},{"location":"LCD/#escanear-dispositivos-i2c","text":"Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la Figura 3.12.7. Figura 3.12.7. Menu I2C Un sencillo programa como el de la Figura 3.12.9 nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Smart-home-detectar-IIC . No se requiere ning\u00fan bloque para enviar datos a la consola porque lo hace el propio bloque de escaneo. Figura 3.12.8. Smart-home-detectar-IIC Si conectamos la consola el resultado de tener la Smart home conectada es el de la Figura 3.12.9. Figura 3.12.9. Consola para el programa Smart-home-detectar-IIC","title":"Escanear dispositivos I2C"},{"location":"LCD/#cambiar-la-direccion-fisica-de-un-dispositivo-i2c","text":"Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la Figura 3.12.10. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Figura 3.12.10. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la Figura 3.12.11 se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Figura 3.12.11. Direcci\u00f3n 0x26","title":"Cambiar la direcci\u00f3n f\u00edsica de un dispositivo I2C"},{"location":"LCD/#definicion-de-simbolos-en-la-lcd","text":"Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la Figura 3.12.12. Figura 3.12.12. Ejemplo de s\u00edmbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque.","title":"Definici\u00f3n de s\u00edmbolos en la LCD"},{"location":"LCD/#multitarea","text":"Este apartado se extrae de ArduinoBlocks - FreeBook disponible en Free Book (online & updated) . ArduinoBlocks nos permite utilizar una capa para implementar un sistema multitarea avanzado basado en FreeRTOS (del ingl\u00e9s Real Time Operating System), que es un sistema operativo de tiempo real kernel para dispositivos embebidos para plataformas de microcontrolador que se distribuye bajo licencia MIT. Este sistema permite crear tareas que se ejecutar\u00e1n de forma paralela (virtualmente). En microcontroladores modestos como el Arduino UNO, Nano o incluso MEGA la multitarea con FreeRTOS es bastante limitada y consume gran parte de los recursos de nuestro Arduino, en caso de necesitar de un sistema multitarea m\u00e1s potente podemos optar por usarlo en placas basadas en ESP8266 o ESP32 con mucha m\u00e1s potencia y recursos (especialmente el ESP32 con doble n\u00facleo y gran potencia de procesamiento y memoria interna) Los sistemas software de multitarea utilizan un planificador o scheduler que se encarga de repartir el tiempo de procesamiento entre las distintas tareas, de forma que a cada una le toca un tiempo de microcontrolador para ejecutar un poquito de su parte de programa. En las web de freeRTOS , en su entrada de men\u00fa Kerne podemos encontrar los conceptos b\u00e1sicos de multitarea y de programaci\u00f3n que vamos a extractar seguidamente.","title":"Multitarea"},{"location":"LCD/#conceptos-basicos-de-multitarea","text":"Un procesador convencional como el de Arduino UNO solo puede ejecutar una tarea a la vez, pero al cambiar r\u00e1pidamente entre tareas, un sistema operativo multitarea puede hacer que parezca que cada tarea se ejecuta simult\u00e1neamente. Esto es lo que se representa en el diagrama de la Figura 3.12.13 que muestra el patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo. Los nombres de las tareas est\u00e1n codificados por colores y escritos a la izquierda. El tiempo se mueve de izquierda a derecha y las l\u00edneas de colores muestran qu\u00e9 tarea se est\u00e1 ejecutando en un momento determinado. El diagrama superior demuestra el patr\u00f3n de ejecuci\u00f3n concurrente percibido, y el inferior el patr\u00f3n de ejecuci\u00f3n multitarea real. Figura 3.12.13. Patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo","title":"Conceptos b\u00e1sicos de multitarea"},{"location":"LCD/#programacion","text":"El programador es quien debe decidir qu\u00e9 tarea debe ejecutarse en un momento determinado. El kernel o n\u00facleo puede suspender y luego reanudar una tarea muchas veces durante el tiempo de vida de la tarea. Adem\u00e1s de ser suspendida involuntariamente por el n\u00facleo o kernel, una tarea puede optar por suspenderse a s\u00ed misma. Har\u00e1 esto si desea retrasar ( dormir ) por un per\u00edodo fijo o esperar ( bloquear ) a que un recurso (por ejemplo, un puerto serie) est\u00e9 disponible, o que ocurra un evento (por ejemplo, presionar una pulsador). Una tarea bloqueada o inactiva no se puede ejecutar y no se le asignar\u00e1 ning\u00fan tiempo de procesamiento. En la Figura 3.12.14 vemos un posible diagrama de ejecuci\u00f3n de tres tareas analizado punto por punto en distintos instantes de tiempo. En los c\u00edculos se representan los instantes de tiempo t1 a t10. Figura 3.12.14. Diagrama de ejecuci\u00f3n de tres tareas en el tiempo t1: la tarea 1 se est\u00e1 ejecutando. t2: en el kernel se suspende, o mejor dicho se intercambia, la tarea 1 . t3: se reanuda la tarea 2 . t4: mientras se ejecuta la tarea 2 el procesador bloquea el puerto serie para su acceso exclusivo. t5: el kernel suspende la tarea 2 . t6: el kernel reanuda la tarea 3 . t1: la tarea 3 intenta acceder al puerto serie y lo encuentra bloqueado por lo que no puede continuar y se suspende. t8: el kernel reanuda la tarea 1 . t9: al ejecutarse de nuevo la tarea 2 se desbloquea el puerto serie. t10: la tarea 3 ahora si puede acceder al puerto serie y se ejecuta al completo","title":"Programaci\u00f3n"},{"location":"LCD/#planificadores","text":"Los planificadores de multitarea permiten asignar a cada tarea una prioridad, para as\u00ed darle preferencia a las tareas m\u00e1s cr\u00edticas o que necesitan m\u00e1s tiempo de procesamiento. Si creamos muchas tareas con \u201calta\u201d prioridad puede que afectemos a las dem\u00e1s dejando poco tiempo de procesamiento para ellas. En la Figura 3.12.15 vemos un esquema de varias tareas con distintas prioridades, variando as\u00ed su tiempo de microprocesador asignado. Figura 3.12.15. Distintas prioridades en tres tareas Cada tarea tiene su propio espacio de memoria, por lo que crear demasiadas tareas tambi\u00e9n puede dejarnos el procesador sin memoria. Si la memoria asignada a las tareas tampoco es suficiente para almacenar los datos se podr\u00eda reiniciar de forma inesperada el Arduino, o funcionar incorrectamente, es decir que como siempre, hay que ser consciente de los limitados recursos de los que disponemos.","title":"Planificadores"},{"location":"LCD/#semaforos","text":"Con la introducci\u00f3n te\u00f3rica a la multitarea vista, debemos hacernos otra pregunta: \u00bfQu\u00e9 pasa si una tarea accede a un recurso o variable, y el sistema multitarea le da el control a otra tarea y por tanto ese proceso falla o quiz\u00e1s otra tarea acceda al mismo recurso y se solapen? Para ese problema de convivencia entre tareas se inventaron los \u201csem\u00e1foros\u201d, en concreto el que m\u00e1s nos interesa es el sem\u00e1foro \u201cmutex\u201d o de exclusi\u00f3n mutua, que permite que bloqueemos el sistema multitarea, hagamos lo que tengamos que hacer cr\u00edtico, y luego liberemos el control. Por supuesto estas tareas cr\u00edticas deben ser lo m\u00e1s cortas y at\u00f3micas posibles: una escritura cr\u00edtica en una variable, un env\u00edo de un dato, una actualizaci\u00f3n de una pantalla LCD,... siempre cosas simples. Los sem\u00e1foros debemos usarlos en casos que tengamos claro que se pueden crear conflictos, pues su abuso puede hacer que el sistema multitarea empiece a fallar. En la Figura 3.12.16 vemos el esquema de acceso a un recurso desde dos tareas diferentes. Figura 3.12.16. Esquema de acceso a un mismo recurso por parte de 2 tareas diferentes","title":"Sem\u00e1foros"},{"location":"LCD/#bloques-esperar","text":"\u00bfQu\u00e9 pasa con los bloques tipo \u201cesperar\u201d que estaban tan prohibidos en la programaci\u00f3n de Arduino cuando quer\u00edamos simular una multitarea antes de tener estos bloques? Pues seguimos teni\u00e9ndoles bastante tirria. Aunque en teor\u00eda podr\u00edamos usarlos, un bloque esperar hace pensar al microcontrolador que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed, por lo que el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! Tenemos una soluci\u00f3n, tenemos un nuevo bloque de esperar \u201ctask friendly\u201d que en lugar de esperar sin hacer nada le dice al sistema: \u00a1voy a estar un rato sin hacer nada, permite ejecutar otras tareas mientras y luego vuelves! \u2026.Mucho m\u00e1s \u201cfriendly\u201d, claro que s\u00ed.","title":"Bloques esperar"},{"location":"LCD/#bloques","text":"Con toda esta informaci\u00f3n pasamos a ver los bloques disponibles para poner todo \u00e9sto en marcha. Bloque Descripci\u00f3n Permite crear una nueva tarea con su bloque de \u201cinicializar\u201d y su \u201cbucle\u201d al igual que la tarea original de Arduino. Debemos asignar una prioridad a cada tarea, por defecto dejar\u00eda todas a \u201cbaja\u201d y luego ir\u00eda ajustando si hace falta. Para gestionar mejor las prioridades, es recomendable en algunos casos no utilizar el \u201cinicializar\u201d y \u201cbucle\u201d propio de Arduino que suele tener preferencia sobre todas estas tareas y es m\u00e1s dif\u00edcil de equilibrar las prioridades. El bloque esperar \u00f3ptimo para tareas, pues deja funcionar al resto de tareas de forma m\u00e1s \u00f3ptima mientras se espera en \u00e9sta. Este bloque tiene menos precisi\u00f3n que el bloque \u201cesperar\u201d original, si necesitamos hacer esperas muy precisas (o de menos de 20 ms) debemos usar el \u201cesperar\u201d tradicional. Pero nos servir\u00e1 en la mayor\u00eda de casos. Si tenemos que hacer alguna acci\u00f3n cr\u00edtica que no queremos que sea interrumpida internamente por el planificador del sistema multitarea podemos poner este bloque y dentro los bloques cr\u00edticos. (no utilizar si no es estrictamente necesario) Cada tarea tiene su propio espacio de memoria reservado, esta es la cantidad por defecto para las tareas (192 bytes), si necesitamos ajustarla podemos utilizar este bloque en el \u201cinicializar\u201d principal y se ajustar\u00e1 para todas las tareas. Un mal ajuste puede provocar reinicios del microcontrolador o mal funcionamiento. Las tareas en principio, igual que el bucle de Arduino, est\u00e1n pensadas para ejecutarse de forma indefinida, si en un caso una tarea deja de ser necesaria la forma de terminarla es con este bloque que parar\u00e1 la ejecuci\u00f3n y liberar\u00e1 la memoria de la tarea en la que se ejecuta.","title":"Bloques"},{"location":"LCD/#actividades","text":"","title":"Actividades"},{"location":"LCD/#actividad-a11_1","text":"En esta actividad enviaremos un texto a la LCD. El programa final lo tenemos disponible en el enlace Smart-home-A11_1 . Figura 3.2.17. Soluci\u00f3n A11_1","title":"Actividad A11_1"},{"location":"LCD/#actividad-a11_2","text":"En esta actividad enviaremos a la LCD el valor le\u00eddo por la LDR y el nombre de la canci\u00f3n que suena de forma simult\u00e1nea como primera tarea. Una segunda tarea es reproducir distintas canciones y actualizar el nombre de la variable. El programa final lo tenemos disponible en el enlace Smart-home-A11_2 . Figura 3.2.18. Soluci\u00f3n A11_2","title":"Actividad A11_2"},{"location":"LDR/","text":"3.6. A05-Fotoc\u00e9lula LDR \u00b6 Teor\u00eda \u00b6 Una fotorresistencia, fotorresistor o LDR es un componente electr\u00f3nico cuya resistencia disminuye de forma exponencial con el aumento de la intensidad de luz incidente. Las siglas LDR vienen de su nombre en ingl\u00e9s, que es Light Dependent Resistor. En la imagen siguiente tenemos el s\u00edmbolo, el aspecto real de una LDR y su curva caracter\u00edstica de variaci\u00f3n de resistencia con la iluminaci\u00f3n. Simbolo y aspecto de la LDR Curva caracter\u00edstica Actividad A05_1 \u00b6 Esta primera actividad va a consistir sencillamente en detectar el nivel de iluminaci\u00f3n con la LDR (pin A1) y enviar el resultado a la consola. La soluci\u00f3n la tenemos disponible en Smart-home-A05_1 . Figura 3.6.1. Soluci\u00f3n A05_1 En la Figura 3.6.2 vemos el resultado generado en la consola. Figura 3.6.2. Consola A05_1 Actividad A05_2 \u00b6 Programar un interruptor crepuscular utilizando la LDR (pin A1) y el LED exterior de color blanco (pin 13) que simula el farol exterior. El nivel de luz m\u00ednimo permitido antes de encender el farol es del 30%, de forma que con un valor menor o igual al 30% se encienda el LED y con un valor mayor permanezca apagado. La soluci\u00f3n la tenemos disponible en Smart-home-A05_2 . Figura 3.6.3. Soluci\u00f3n A05_2","title":"3.6. A05-Fotoc\u00e9lula LDR"},{"location":"LDR/#36-a05-fotocelula-ldr","text":"","title":"3.6. A05-Fotoc\u00e9lula LDR"},{"location":"LDR/#teoria","text":"Una fotorresistencia, fotorresistor o LDR es un componente electr\u00f3nico cuya resistencia disminuye de forma exponencial con el aumento de la intensidad de luz incidente. Las siglas LDR vienen de su nombre en ingl\u00e9s, que es Light Dependent Resistor. En la imagen siguiente tenemos el s\u00edmbolo, el aspecto real de una LDR y su curva caracter\u00edstica de variaci\u00f3n de resistencia con la iluminaci\u00f3n. Simbolo y aspecto de la LDR Curva caracter\u00edstica","title":"Teor\u00eda"},{"location":"LDR/#actividad-a05_1","text":"Esta primera actividad va a consistir sencillamente en detectar el nivel de iluminaci\u00f3n con la LDR (pin A1) y enviar el resultado a la consola. La soluci\u00f3n la tenemos disponible en Smart-home-A05_1 . Figura 3.6.1. Soluci\u00f3n A05_1 En la Figura 3.6.2 vemos el resultado generado en la consola. Figura 3.6.2. Consola A05_1","title":"Actividad A05_1"},{"location":"LDR/#actividad-a05_2","text":"Programar un interruptor crepuscular utilizando la LDR (pin A1) y el LED exterior de color blanco (pin 13) que simula el farol exterior. El nivel de luz m\u00ednimo permitido antes de encender el farol es del 30%, de forma que con un valor menor o igual al 30% se encienda el LED y con un valor mayor permanezca apagado. La soluci\u00f3n la tenemos disponible en Smart-home-A05_2 . Figura 3.6.3. Soluci\u00f3n A05_2","title":"Actividad A05_2"},{"location":"agas/","text":"5.1. Reto 1 - Alarma por gas \u00b6 Realizar un programa que emita un sonido y ponga intermitente el diodo LED amarillo si se supera el nivel de gas establecido. Se muestra informaci\u00f3n en la pantalla LCD del nivel de gas detectado. En la Figura 5.1.1 vemos el programa en ArduinoBlocks. Figura 5.1.1. Soluci\u00f3n Reto 1 En la visualizaci\u00f3n en pantalla los valores de gas se muestran en tanto por ciento. En el enlace Smart-home-Reto1 tenemos el programa listo para verlo y traerlo a nuestros proyectos. Si preferimos descargar el proyecto a nuestro ordenador, desde el archivo Smart-home-Reto1.abp podemos hacerlo para posteriormente importarlo.","title":"5.1. Reto 1 - Alarma por gas"},{"location":"agas/#51-reto-1-alarma-por-gas","text":"Realizar un programa que emita un sonido y ponga intermitente el diodo LED amarillo si se supera el nivel de gas establecido. Se muestra informaci\u00f3n en la pantalla LCD del nivel de gas detectado. En la Figura 5.1.1 vemos el programa en ArduinoBlocks. Figura 5.1.1. Soluci\u00f3n Reto 1 En la visualizaci\u00f3n en pantalla los valores de gas se muestran en tanto por ciento. En el enlace Smart-home-Reto1 tenemos el programa listo para verlo y traerlo a nuestros proyectos. Si preferimos descargar el proyecto a nuestro ordenador, desde el archivo Smart-home-Reto1.abp podemos hacerlo para posteriormente importarlo.","title":"5.1. Reto 1 - Alarma por gas"},{"location":"app/","text":"4.2. APP \u00b6 Este apartado lo dedicamos a la descripci\u00f3n y uso de la aplicaci\u00f3n de Keyestudio \u201ckeyes IoT\u201d pensada para el control por Bluetooth de los elementos de la Smart home. Antes de nada debemos instalar la aplicaci\u00f3n en nuestro m\u00f3vil. Vamos a ver solamente para el sistema Android. Podemos instalar la aplicaci\u00f3n por cualquiera de estos medios: Descargar \"IoT Keyes\" desde el dropbox de keyestudio: Enlace a manual en ingl\u00e9s y app Descargar \"IoT Keyes\" desde el repo de esta web: Descarga keyes IoT.apk Instalarla desde Play Store, que quiz\u00e1 sea la forma mas sencilla Una vez instalada la aplicaci\u00f3n en nuestro m\u00f3vil se mostrar\u00e1 el icono que vemos en la Figura 4.2.1. Figura 4.2.1. Icono IoT keyes Cuando abrimos la aplicaci\u00f3n la pantalla se ver\u00e1 como en la Figura 4.2.2. Figura 4.2.2. Ventana principal de la aplicaci\u00f3n Hay 16 botones de control en la aplicaci\u00f3n que al presionarlos se env\u00eda desde el tel\u00e9fono un determinado car\u00e1cter si est\u00e1 desactivado y otro si el bot\u00f3n ha sido activado previamente. Esta situaci\u00f3n se diferencia porque cuando el bot\u00f3n est\u00e1 pulsado aparece en pantalla difuminado. En la Figura 4.2.3 vemos algunos botones en esta situaci\u00f3n de pulsados (enmarcados en rojo) y el resto sin pulsar. Podemos decir que los botones act\u00faan como interruptores pues mantienen su posici\u00f3n. Figura 4.2.3. Pantalla app con algunos botones accionados Hay dos botones espaciales que se han enmarcado en un rect\u00e1ngulo morado, son los de m\u00fasica y estos no se activan como el resto, sino que env\u00edan un car\u00e1cter mientras se mantienen pulsados y otro cuando se sueltan, es decir, dos caracteres en lugar de uno. Por otro lado tenemos las barras deslizantes para hacer el control PWM del servo de la puerta, del de la ventana, de la luminosidad del LED blanco y la velocidad del motor DC del ventilador. Estos deslizados env\u00edan un n\u00famero que representa el valor del deslizador y un c\u00f3digo de finalizaci\u00f3n que es el car\u00e1cter #. El valor de los deslizadores de la puerta y la ventana var\u00eda entre 0 y 180 y el del LED y el ventilador entre 0 y 250. Es decir, los botones de esta columna abren o cierran la puerta o la ventana y activan o desactivan la luz y el ventilador y los deslizadores controlan los \u00e1ngulos de movimiento de los servos entre 0 y 180\u00ba, el nivel de luz emitido y la velocidad del ventilador. Estos c\u00f3digos que env\u00eda nuestro m\u00f3vil los recibe el Bluetooth y son enviados a la placa de control, lo que nos permitir\u00e1 programar una aplicaci\u00f3n de control de la Smart home desde el m\u00f3vil con esta aplicaci\u00f3n. Nuestra primera tarea ser\u00e1 averiguar los c\u00f3digos que la app env\u00eda, como veremos posteriormente. En la parte superior izquierda de la ventana de la app tenemos el bot\u00f3n \"SCANNING\", que si lo pulsamos nos va a mostrar una lista de todos los dispositivos Bluetooth que est\u00e9n en el alcance del m\u00f3vil. Teniendo alimentada la smart home y el m\u00f3dulo HM-10 conectado vemos que el LED que lleva incorporado parpadea. En esta situaci\u00f3n pulsamos el bot\u00f3n \"SCANNING\" y se nos mostrar\u00e1 la lista donde debemos encontrar uno llamado HMSoft , tal y como vemos en la Figura 4.2.4, donde observamos como ese dispositivo se marca como conectado. Figura 4.2.4. Lista de dispositivos escaneados Si pulsamos el bot\u00f3n rojo 'connect' el LED en el m\u00f3dulo dejar\u00e1 de parpadear, la situaci\u00f3n cambia a conectado (Figura 4.2.5) y sobre el bot\u00f3n rojo aparece el texto \"is connected\", indicando precisamente la situaci\u00f3n de que la app y el m\u00f3dulo est\u00e1n conectados v\u00eda Bluetooth. En la imagen de la Figura 5.2.5 observamos el nombre del dispositivo Bluetooth (HMSoft) y debajo la direcci\u00f3n MAC del mismo, por si necesitamos trabajar con ella. Figura 4.2.5. HMSoft conectado con el HM-10 Si volvemos a pulsar el bot\u00f3n rojo desconectamos los dispositivos volviendo a la situaci\u00f3n de partida. Si tocamos en cualquier parte de la pantalla fuera de la que abarcan los botones (zona en primer plano en blanco y rojo) estaremos en situaci\u00f3n de trabajar con la app enviando datos a la placa. En la Figura 4.2.6 vemos el estado de la pantalla con los dispositivos conectados. Figura 4.2.6. App lista para enviar c\u00f3digos En dispositivos Android debemos permitir que la aplicaci\u00f3n acceda a la \"ubicaci\u00f3n\" cuando la app est\u00e1 en uso; de lo contrario, es posible que el Bluetooth no permanezca conectado. Programa de prueba \u00b6 Antes de hacer nada mas con la app necesitamos saber los c\u00f3digo que env\u00eda cuando pulsamos cada uno de los botones y cuando cambiamos la posici\u00f3n de los deslizadores. En la documentaci\u00f3n KS0085 Keyestudio Smart Home Kit for Arduino podemos encontrar la informaci\u00f3n, en ingl\u00e9s, referida al car\u00e1cter de control y la funci\u00f3n de cada parte de la app y un ejemplo para el IDE de Arduino, vamos a crear un programa en ArdinoBlocks que nos muestre en la LCD, en cada momento, el comando que se ha enviado desde el m\u00f3vil y que se ha recibido en la placa de control. Debemos cargar en nuestra placa \"PLUS\" el programa Smart-home-test-app que vemos en la Figura 4.2.7 y comprobar los c\u00f3digo enviados por cada elemento de la app. Figura 4.2.7. Programa de prueba de la app Recordemos que para poder cargar el programa en la placa debemos desconectar al menos uno de los pines Tx o Rx del m\u00f3dulo Bluetooth o nos generar\u00e1 un error. Una vez cargado el programa reconectamos el Bluetooth, abrimos la app, tocamos en \"SCANNING\" para conectarnos con el m\u00f3dulo HM-10 de nombre \"HMSoft\" y una vez conectados comenzamos a enviar c\u00f3digos desde la app para ver su valor ASCII (letras) y/o num\u00e9rico (deslizadores) enviado. Descripci\u00f3n botones de la app \u00b6 En la Figura 4.2.8 vemos resumidos los botones de las dos primeras columnas, los caracteres de control y la funci\u00f3n que tienen. Figura 4.2.8. Funci\u00f3n y caracteres de botones de las dos primeras columnas En la Figura 4.2.9 vemos resumidos los botones restantes, los caracteres de control y la funci\u00f3n que tienen. En esta ocasi\u00f3n el bot\u00f3n env\u00eda su car\u00e1cter de control y el deslizador un n\u00famero (nnn) seguido del s\u00edmbolo # que indica que hemos soltado la barra deslizante. La codificaci\u00f3n del deslizador es, para el caso de la puerta, tnnn#, donde t indica abrir la puerta, nnn el valor de la barra y # el car\u00e1cter de finalizaci\u00f3n. Figura 4.2.9. Funci\u00f3n y caracteres de botones restantes y deslizadores","title":"4.2. APP"},{"location":"app/#42-app","text":"Este apartado lo dedicamos a la descripci\u00f3n y uso de la aplicaci\u00f3n de Keyestudio \u201ckeyes IoT\u201d pensada para el control por Bluetooth de los elementos de la Smart home. Antes de nada debemos instalar la aplicaci\u00f3n en nuestro m\u00f3vil. Vamos a ver solamente para el sistema Android. Podemos instalar la aplicaci\u00f3n por cualquiera de estos medios: Descargar \"IoT Keyes\" desde el dropbox de keyestudio: Enlace a manual en ingl\u00e9s y app Descargar \"IoT Keyes\" desde el repo de esta web: Descarga keyes IoT.apk Instalarla desde Play Store, que quiz\u00e1 sea la forma mas sencilla Una vez instalada la aplicaci\u00f3n en nuestro m\u00f3vil se mostrar\u00e1 el icono que vemos en la Figura 4.2.1. Figura 4.2.1. Icono IoT keyes Cuando abrimos la aplicaci\u00f3n la pantalla se ver\u00e1 como en la Figura 4.2.2. Figura 4.2.2. Ventana principal de la aplicaci\u00f3n Hay 16 botones de control en la aplicaci\u00f3n que al presionarlos se env\u00eda desde el tel\u00e9fono un determinado car\u00e1cter si est\u00e1 desactivado y otro si el bot\u00f3n ha sido activado previamente. Esta situaci\u00f3n se diferencia porque cuando el bot\u00f3n est\u00e1 pulsado aparece en pantalla difuminado. En la Figura 4.2.3 vemos algunos botones en esta situaci\u00f3n de pulsados (enmarcados en rojo) y el resto sin pulsar. Podemos decir que los botones act\u00faan como interruptores pues mantienen su posici\u00f3n. Figura 4.2.3. Pantalla app con algunos botones accionados Hay dos botones espaciales que se han enmarcado en un rect\u00e1ngulo morado, son los de m\u00fasica y estos no se activan como el resto, sino que env\u00edan un car\u00e1cter mientras se mantienen pulsados y otro cuando se sueltan, es decir, dos caracteres en lugar de uno. Por otro lado tenemos las barras deslizantes para hacer el control PWM del servo de la puerta, del de la ventana, de la luminosidad del LED blanco y la velocidad del motor DC del ventilador. Estos deslizados env\u00edan un n\u00famero que representa el valor del deslizador y un c\u00f3digo de finalizaci\u00f3n que es el car\u00e1cter #. El valor de los deslizadores de la puerta y la ventana var\u00eda entre 0 y 180 y el del LED y el ventilador entre 0 y 250. Es decir, los botones de esta columna abren o cierran la puerta o la ventana y activan o desactivan la luz y el ventilador y los deslizadores controlan los \u00e1ngulos de movimiento de los servos entre 0 y 180\u00ba, el nivel de luz emitido y la velocidad del ventilador. Estos c\u00f3digos que env\u00eda nuestro m\u00f3vil los recibe el Bluetooth y son enviados a la placa de control, lo que nos permitir\u00e1 programar una aplicaci\u00f3n de control de la Smart home desde el m\u00f3vil con esta aplicaci\u00f3n. Nuestra primera tarea ser\u00e1 averiguar los c\u00f3digos que la app env\u00eda, como veremos posteriormente. En la parte superior izquierda de la ventana de la app tenemos el bot\u00f3n \"SCANNING\", que si lo pulsamos nos va a mostrar una lista de todos los dispositivos Bluetooth que est\u00e9n en el alcance del m\u00f3vil. Teniendo alimentada la smart home y el m\u00f3dulo HM-10 conectado vemos que el LED que lleva incorporado parpadea. En esta situaci\u00f3n pulsamos el bot\u00f3n \"SCANNING\" y se nos mostrar\u00e1 la lista donde debemos encontrar uno llamado HMSoft , tal y como vemos en la Figura 4.2.4, donde observamos como ese dispositivo se marca como conectado. Figura 4.2.4. Lista de dispositivos escaneados Si pulsamos el bot\u00f3n rojo 'connect' el LED en el m\u00f3dulo dejar\u00e1 de parpadear, la situaci\u00f3n cambia a conectado (Figura 4.2.5) y sobre el bot\u00f3n rojo aparece el texto \"is connected\", indicando precisamente la situaci\u00f3n de que la app y el m\u00f3dulo est\u00e1n conectados v\u00eda Bluetooth. En la imagen de la Figura 5.2.5 observamos el nombre del dispositivo Bluetooth (HMSoft) y debajo la direcci\u00f3n MAC del mismo, por si necesitamos trabajar con ella. Figura 4.2.5. HMSoft conectado con el HM-10 Si volvemos a pulsar el bot\u00f3n rojo desconectamos los dispositivos volviendo a la situaci\u00f3n de partida. Si tocamos en cualquier parte de la pantalla fuera de la que abarcan los botones (zona en primer plano en blanco y rojo) estaremos en situaci\u00f3n de trabajar con la app enviando datos a la placa. En la Figura 4.2.6 vemos el estado de la pantalla con los dispositivos conectados. Figura 4.2.6. App lista para enviar c\u00f3digos En dispositivos Android debemos permitir que la aplicaci\u00f3n acceda a la \"ubicaci\u00f3n\" cuando la app est\u00e1 en uso; de lo contrario, es posible que el Bluetooth no permanezca conectado.","title":"4.2. APP"},{"location":"app/#programa-de-prueba","text":"Antes de hacer nada mas con la app necesitamos saber los c\u00f3digo que env\u00eda cuando pulsamos cada uno de los botones y cuando cambiamos la posici\u00f3n de los deslizadores. En la documentaci\u00f3n KS0085 Keyestudio Smart Home Kit for Arduino podemos encontrar la informaci\u00f3n, en ingl\u00e9s, referida al car\u00e1cter de control y la funci\u00f3n de cada parte de la app y un ejemplo para el IDE de Arduino, vamos a crear un programa en ArdinoBlocks que nos muestre en la LCD, en cada momento, el comando que se ha enviado desde el m\u00f3vil y que se ha recibido en la placa de control. Debemos cargar en nuestra placa \"PLUS\" el programa Smart-home-test-app que vemos en la Figura 4.2.7 y comprobar los c\u00f3digo enviados por cada elemento de la app. Figura 4.2.7. Programa de prueba de la app Recordemos que para poder cargar el programa en la placa debemos desconectar al menos uno de los pines Tx o Rx del m\u00f3dulo Bluetooth o nos generar\u00e1 un error. Una vez cargado el programa reconectamos el Bluetooth, abrimos la app, tocamos en \"SCANNING\" para conectarnos con el m\u00f3dulo HM-10 de nombre \"HMSoft\" y una vez conectados comenzamos a enviar c\u00f3digos desde la app para ver su valor ASCII (letras) y/o num\u00e9rico (deslizadores) enviado.","title":"Programa de prueba"},{"location":"app/#descripcion-botones-de-la-app","text":"En la Figura 4.2.8 vemos resumidos los botones de las dos primeras columnas, los caracteres de control y la funci\u00f3n que tienen. Figura 4.2.8. Funci\u00f3n y caracteres de botones de las dos primeras columnas En la Figura 4.2.9 vemos resumidos los botones restantes, los caracteres de control y la funci\u00f3n que tienen. En esta ocasi\u00f3n el bot\u00f3n env\u00eda su car\u00e1cter de control y el deslizador un n\u00famero (nnn) seguido del s\u00edmbolo # que indica que hemos soltado la barra deslizante. La codificaci\u00f3n del deslizador es, para el caso de la puerta, tnnn#, donde t indica abrir la puerta, nnn el valor de la barra y # el car\u00e1cter de finalizaci\u00f3n. Figura 4.2.9. Funci\u00f3n y caracteres de botones restantes y deslizadores","title":"Descripci\u00f3n botones de la app"},{"location":"buzz/","text":"3.3. A02-Zumbador o buzzer \u00b6 El zumbador \u00b6 El buzzer o zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de dos tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido. El zumbador que incorpora la smart house es de tipo pasivo y est\u00e1 conectado al pin D3. Una de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas En ArduinoBlocks disponemos de un bloque que nos permite reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: Bloque Reproducir RTTTL Este bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melodia es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente. Funciones \u00b6 Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas Actividad A02_1 \u00b6 En el bloque Zumbador podemos modificar dos par\u00e1metros, el tiempo que dura cada sonido expresado en milisegundos (campo Ms) y la frecuencia en Hz a la que reproducir\u00e1 el sonido el zumbador (campo Hz). Vamos a comenzar haciendo un programa (Figura 3.3.1) que reproduzca tres de las notas de la escala musical vista anteriormente. La soluci\u00f3n la tenemos disponible en Smart-home-A02_1 . Figura 3.3.1. Soluci\u00f3n A02_1 Actividad A02_2 \u00b6 Reproducir la escala musical con las notas b\u00e1sicas utilizando los bloques Zumbador y Tono como vemos en la Figura 3.3.2. La soluci\u00f3n la tenemos disponible en Smart-home-A02_2 . Figura 3.3.2. Soluci\u00f3n A02_2 Actividad A02_3 \u00b6 Reproducir la melod\u00eda de la Figura 3.3.3 sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito (duraci\u00f3n de negra mas corchea o lo que es lo mismo, un pulso y medio) 750ms y las blancas 1000ms. Figura 3.3.3. Partitura Se trata de un fragmento del himno a la alegr\u00eda que vamos a programar utilizando funciones. En la Figura 3.3.4 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A02_3 . Figura 3.3.4. Soluci\u00f3n A02_3 Actividad A02_4 \u00b6 Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada). La soluci\u00f3n es sencilla, basta con escoger el bloque Zumbador Reproducir RTTTL y acoplarle el bloque RTTTL escogiendo la melod\u00eda a reproducir. En la soluci\u00f3n se han puestos dos grupos de bloques con dos de las posibles melod\u00edas dejando un tiempo de 5 segundos entre una y otra. En este caso adem\u00e1s los bloques se han colocado en \"Inicializar\" por lo que solamente se van a ejecutar una vez y no de manera indefinida. Si queremos o\u00edrlo de nuevo debemos hacer reset en la placa o desconectar y conectar la alimentaci\u00f3n. En la Figura 3.3.5 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A02_4 . Figura 3.3.5. Soluci\u00f3n A02_4","title":"3.3. A02-Zumbador"},{"location":"buzz/#33-a02-zumbador-o-buzzer","text":"","title":"3.3. A02-Zumbador o buzzer"},{"location":"buzz/#el-zumbador","text":"El buzzer o zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de dos tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido. El zumbador que incorpora la smart house es de tipo pasivo y est\u00e1 conectado al pin D3. Una de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas En ArduinoBlocks disponemos de un bloque que nos permite reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: Bloque Reproducir RTTTL Este bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melodia es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente.","title":"El zumbador"},{"location":"buzz/#funciones","text":"Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas","title":"Funciones"},{"location":"buzz/#actividad-a02_1","text":"En el bloque Zumbador podemos modificar dos par\u00e1metros, el tiempo que dura cada sonido expresado en milisegundos (campo Ms) y la frecuencia en Hz a la que reproducir\u00e1 el sonido el zumbador (campo Hz). Vamos a comenzar haciendo un programa (Figura 3.3.1) que reproduzca tres de las notas de la escala musical vista anteriormente. La soluci\u00f3n la tenemos disponible en Smart-home-A02_1 . Figura 3.3.1. Soluci\u00f3n A02_1","title":"Actividad A02_1"},{"location":"buzz/#actividad-a02_2","text":"Reproducir la escala musical con las notas b\u00e1sicas utilizando los bloques Zumbador y Tono como vemos en la Figura 3.3.2. La soluci\u00f3n la tenemos disponible en Smart-home-A02_2 . Figura 3.3.2. Soluci\u00f3n A02_2","title":"Actividad A02_2"},{"location":"buzz/#actividad-a02_3","text":"Reproducir la melod\u00eda de la Figura 3.3.3 sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito (duraci\u00f3n de negra mas corchea o lo que es lo mismo, un pulso y medio) 750ms y las blancas 1000ms. Figura 3.3.3. Partitura Se trata de un fragmento del himno a la alegr\u00eda que vamos a programar utilizando funciones. En la Figura 3.3.4 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A02_3 . Figura 3.3.4. Soluci\u00f3n A02_3","title":"Actividad A02_3"},{"location":"buzz/#actividad-a02_4","text":"Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada). La soluci\u00f3n es sencilla, basta con escoger el bloque Zumbador Reproducir RTTTL y acoplarle el bloque RTTTL escogiendo la melod\u00eda a reproducir. En la soluci\u00f3n se han puestos dos grupos de bloques con dos de las posibles melod\u00edas dejando un tiempo de 5 segundos entre una y otra. En este caso adem\u00e1s los bloques se han colocado en \"Inicializar\" por lo que solamente se van a ejecutar una vez y no de manera indefinida. Si queremos o\u00edrlo de nuevo debemos hacer reset en la placa o desconectar y conectar la alimentaci\u00f3n. En la Figura 3.3.5 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A02_4 . Figura 3.3.5. Soluci\u00f3n A02_4","title":"Actividad A02_4"},{"location":"controlapp/","text":"5.3. Reto 3 - Control Smart Home con APP \u00b6 En este \u00faltimo reto vamos a programar todas las posibilidades que nos ofrece la APP IoT keyes enviando comandos desde la misma y recibiendo datos desde la Smart home todo en modo de prueba de funcionalidad sin entrar en detalles de aplicaci\u00f3n concreta. Es decir, recibiremos en nuestro m\u00f3vil el nivel de humedad del suelo (valor en bruto entre 0 y 1023) sin tomar ninguna acci\u00f3n, como podr\u00eda ser que se activase una bomba de riego a trav\u00e9s del rel\u00e9, pero estas funcionalidades quedan como propuestas que cada uno resolver\u00e1 seg\u00fan sus preferencias. Utilizaremos como base la informaci\u00f3n del apartado 4.2. APP . En la Figura 5.3.1 vemos el programa en ArduinoBlocks. Podemos observar como al tratarse de un programa bastante grande la visualizaci\u00f3n en pantalla ya no resulta muy buena para poder seguir la imagen y crear nuestro propio programa o entender el funcionamiento. Posteriormente analizamos el programa por partes. Figura 5.3.1. Soluci\u00f3n Reto 2 En el enlace Smart-home-Reto3 tenemos el programa listo para verlo y traerlo a nuestros proyectos. Si preferimos descargar el proyecto a nuestro ordenador, desde el archivo Smart-home-Reto3.abp podemos hacerlo para posteriormente importarlo. Explicaci\u00f3n del programa \u00b6 En la Figura 5.3.2 vemos los bloques \"Inicializar\" y \"Bucle\" adem\u00e1s de la funci\u00f3n \"mensaje-inicial\" que no requieren mayor explicaci\u00f3n. Figura 5.3.2. Bloques \"Inicializar\" y \"Bucle\" y funci\u00f3n \"mensaje-inicial\" Dentro de \"Bucle\" existe un bucle que se ejecuta cada 5 segundos con una llamada a la funci\u00f3n \"info-LCD\" que vemos en la Figura 5.3.3 que se encarga de detectar presencia de forma continuada. Figura 5.3.3. Funci\u00f3n \"info-LCD\" La funci\u00f3n \"comandos-BT\" tiene dos tipos de funcionalidades, la primera parte se encarga de preguntar si se est\u00e1n recibiendo datos por Bluetooth, y si es cierto comienza a tomar acciones que comienzan por guardar en una variable el dato recibido y llamar a la funci\u00f3n \"comando-PWM\" que veremos a posteriori. En la figura 5.3.4 vemos la primera parte de esta funci\u00f3n y se ve la funcionalidad de la primera columna de botones. Figura 5.3.4. Funci\u00f3n \"comandos-BT\" primera columna de botones En la Figura 5.3.5 vemos la segunda columna de botones. En este caso la funcionalidad es totalmente diferente a la anterior y lo que se hace es enviar datos desde los sensores a la APP para que los muestre. Figura 5.3.5. Funci\u00f3n \"comandos-BT\" segunda columna de botones En la Figura 5.3.6 vemos la pantalla de la APP con los botones activados y recibiendo datos de los sensores. Figura 5.3.6. Datos de sensores recibidos en la APP La tercera parte de la funci\u00f3n \"comandos-BT\" es la que vemos en la Figura 5.3.7. Figura 5.3.7. Funci\u00f3n \"comandos-BT\" tercera columna de botones Las funcionalidades son abrir y cerrar la puerta y la ventana, apagar y encender el LED amarillo y encender y apagar el ventilador. La funci\u00f3n \"Comando-PWM\" (Figura 5.3.8) es la encargada de recibir los datos seg\u00fan el comando enviado, recibiendo como texto el valor del deslizador detect\u00e1ndose el final del dato por el car\u00e1cter '#'. Los datos de texto son pasados a num\u00e9ricos para poder actuar con los dispositivos con funciones PWM. Figura 5.3.8. Funci\u00f3n \"comandos-BT\" controles PWM Adem\u00e1s en el programa se ha implementado una funci\u00f3n \"modo-auto\" (Figura 5.3.9) para trabajar con los botones que incorpora la Smart home. Figura 5.3.9. Funci\u00f3n \"modo-auto\" Nota final \u00b6 Con esto hemos llegado al final de la documentaci\u00f3n sobre dom\u00f3tica simulada con el Kit KS0085 Smart Home de Keyestudio. Espero que te diviertas aprendiendo dom\u00f3tica con estas notas. Es mi intenci\u00f3n ampliar los contenidos con otros ejemplos y profundizaci\u00f3n en este tema, pero a septiembre de 2022solamente tendr\u00e1 este contenido.","title":"5.3. Reto 3 - Control Smart Home con APP"},{"location":"controlapp/#53-reto-3-control-smart-home-con-app","text":"En este \u00faltimo reto vamos a programar todas las posibilidades que nos ofrece la APP IoT keyes enviando comandos desde la misma y recibiendo datos desde la Smart home todo en modo de prueba de funcionalidad sin entrar en detalles de aplicaci\u00f3n concreta. Es decir, recibiremos en nuestro m\u00f3vil el nivel de humedad del suelo (valor en bruto entre 0 y 1023) sin tomar ninguna acci\u00f3n, como podr\u00eda ser que se activase una bomba de riego a trav\u00e9s del rel\u00e9, pero estas funcionalidades quedan como propuestas que cada uno resolver\u00e1 seg\u00fan sus preferencias. Utilizaremos como base la informaci\u00f3n del apartado 4.2. APP . En la Figura 5.3.1 vemos el programa en ArduinoBlocks. Podemos observar como al tratarse de un programa bastante grande la visualizaci\u00f3n en pantalla ya no resulta muy buena para poder seguir la imagen y crear nuestro propio programa o entender el funcionamiento. Posteriormente analizamos el programa por partes. Figura 5.3.1. Soluci\u00f3n Reto 2 En el enlace Smart-home-Reto3 tenemos el programa listo para verlo y traerlo a nuestros proyectos. Si preferimos descargar el proyecto a nuestro ordenador, desde el archivo Smart-home-Reto3.abp podemos hacerlo para posteriormente importarlo.","title":"5.3. Reto 3 - Control Smart Home con APP"},{"location":"controlapp/#explicacion-del-programa","text":"En la Figura 5.3.2 vemos los bloques \"Inicializar\" y \"Bucle\" adem\u00e1s de la funci\u00f3n \"mensaje-inicial\" que no requieren mayor explicaci\u00f3n. Figura 5.3.2. Bloques \"Inicializar\" y \"Bucle\" y funci\u00f3n \"mensaje-inicial\" Dentro de \"Bucle\" existe un bucle que se ejecuta cada 5 segundos con una llamada a la funci\u00f3n \"info-LCD\" que vemos en la Figura 5.3.3 que se encarga de detectar presencia de forma continuada. Figura 5.3.3. Funci\u00f3n \"info-LCD\" La funci\u00f3n \"comandos-BT\" tiene dos tipos de funcionalidades, la primera parte se encarga de preguntar si se est\u00e1n recibiendo datos por Bluetooth, y si es cierto comienza a tomar acciones que comienzan por guardar en una variable el dato recibido y llamar a la funci\u00f3n \"comando-PWM\" que veremos a posteriori. En la figura 5.3.4 vemos la primera parte de esta funci\u00f3n y se ve la funcionalidad de la primera columna de botones. Figura 5.3.4. Funci\u00f3n \"comandos-BT\" primera columna de botones En la Figura 5.3.5 vemos la segunda columna de botones. En este caso la funcionalidad es totalmente diferente a la anterior y lo que se hace es enviar datos desde los sensores a la APP para que los muestre. Figura 5.3.5. Funci\u00f3n \"comandos-BT\" segunda columna de botones En la Figura 5.3.6 vemos la pantalla de la APP con los botones activados y recibiendo datos de los sensores. Figura 5.3.6. Datos de sensores recibidos en la APP La tercera parte de la funci\u00f3n \"comandos-BT\" es la que vemos en la Figura 5.3.7. Figura 5.3.7. Funci\u00f3n \"comandos-BT\" tercera columna de botones Las funcionalidades son abrir y cerrar la puerta y la ventana, apagar y encender el LED amarillo y encender y apagar el ventilador. La funci\u00f3n \"Comando-PWM\" (Figura 5.3.8) es la encargada de recibir los datos seg\u00fan el comando enviado, recibiendo como texto el valor del deslizador detect\u00e1ndose el final del dato por el car\u00e1cter '#'. Los datos de texto son pasados a num\u00e9ricos para poder actuar con los dispositivos con funciones PWM. Figura 5.3.8. Funci\u00f3n \"comandos-BT\" controles PWM Adem\u00e1s en el programa se ha implementado una funci\u00f3n \"modo-auto\" (Figura 5.3.9) para trabajar con los botones que incorpora la Smart home. Figura 5.3.9. Funci\u00f3n \"modo-auto\"","title":"Explicaci\u00f3n del programa"},{"location":"controlapp/#nota-final","text":"Con esto hemos llegado al final de la documentaci\u00f3n sobre dom\u00f3tica simulada con el Kit KS0085 Smart Home de Keyestudio. Espero que te diviertas aprendiendo dom\u00f3tica con estas notas. Es mi intenci\u00f3n ampliar los contenidos con otros ejemplos y profundizaci\u00f3n en este tema, pero a septiembre de 2022solamente tendr\u00e1 este contenido.","title":"Nota final"},{"location":"gas/","text":"3.11. A10-Sensor de gas MQ-2 \u00b6 Teor\u00eda \u00b6 Toda la serie MQ son sensores electroqu\u00edmicos y var\u00edan su resistencia cuando se exponen a determinados gases, internamente poseen un calentador (es normal que los toquemos y notemos el calor) encargado de aumentar la temperatura interna y con esto el sensor pueda reaccionar con los gases provocando un cambio en el valor de la resistencia. En la Figura 3.11.1 tenemos diagramas b\u00e1sicos de como est\u00e1n constituidos estos sensores. Figura 3.11.1. Diagramas sensores MQ El material sensible es el di\u00f3xido de esta\u00f1o (SnO2) que tiene menor conductividad cuando el aire est\u00e1 limpio y aumenta esta cuando detecta un aumento de la concentraci\u00f3n de gases. Los sensores MQ requieren esperar un tiempo de calentamiento para que la salida sea estable y tenga las caracter\u00edsticas que el fabricante muestra en sus datasheet, dicho tiempo dependiendo del modelo puede variar entre 12 y 48 horas. En concreto en el datasheet del MQ-2 podemos ver que para este sensor se requieren alrededor de 24 horas. El sensor MQ-2 es adecuado para detectar hidr\u00f3geno, GLP, metano (CH4), Mon\u00f3xido de carbono (CO), alcohol, humo y propano (C3H8). Presenta su mayor sensibilidad a los GLP y al propano. El sensor de gas MQ-2 es anal\u00f3gico y se utiliza en la detecci\u00f3n de fugas de gas de equipos en los mercados de consumo y la industria, este sensor tiene una alta sensibilidad ajustable mediante el potenci\u00f3metro que incorpora el m\u00f3dulo, y un tiempo de respuesta r\u00e1pido. El aspecto del m\u00f3dulo sensor MQ-2 lo vemos en la Figura 3.11.2. Figura 3.11.2. Aspecto MQ-2 El sensor dispone de 4 pines, que son: VCC: Alimentaci\u00f3n positiva de 5V GND: Masa o 0V D0: Se conecta a un pin digital en estado alto y se encarga del calentamiento del sensor. A0: Salida anal\u00f3gica del sensor. Actividad A10_1 \u00b6 En esta actividad vamos a leer directamente el valor entregado por el sensor MQ-2 (pines 11 y A0) enviando los datos al terminal serie. La soluci\u00f3n la tenemos disponible en Smart-home-A10_1 . Figura 3.11.3. Soluci\u00f3n A10_1 En la Figura 3.11.4 vemos los resultados de la lectura en la consola serie y se aprecia el aumento en el aire de alg\u00fan gas y la disminuci\u00f3n cuando este se va disipando. Figura 3.11.4. Consola A10_1 Actividad A10_2 \u00b6 En lugar de enviar los datos a la consola serie como en A10_1 los enviamos al Serial Plotter. La soluci\u00f3n la tenemos disponible en Smart-home-A10_2 . Figura 3.11.5. Soluci\u00f3n A10_2 En la Figura 3.11.6 vemos una captura del datalogger. Figura 3.11.6. Serial plotter A10_2 Actividad A10_3 \u00b6 Montamos una alarma sonora por detecci\u00f3n de gas. La soluci\u00f3n la tenemos disponible en Smart-home-A10_3 . Figura 3.11.7. Soluci\u00f3n A10_3","title":"3.11. A10-Sensor de gas MQ-2"},{"location":"gas/#311-a10-sensor-de-gas-mq-2","text":"","title":"3.11. A10-Sensor de gas MQ-2"},{"location":"gas/#teoria","text":"Toda la serie MQ son sensores electroqu\u00edmicos y var\u00edan su resistencia cuando se exponen a determinados gases, internamente poseen un calentador (es normal que los toquemos y notemos el calor) encargado de aumentar la temperatura interna y con esto el sensor pueda reaccionar con los gases provocando un cambio en el valor de la resistencia. En la Figura 3.11.1 tenemos diagramas b\u00e1sicos de como est\u00e1n constituidos estos sensores. Figura 3.11.1. Diagramas sensores MQ El material sensible es el di\u00f3xido de esta\u00f1o (SnO2) que tiene menor conductividad cuando el aire est\u00e1 limpio y aumenta esta cuando detecta un aumento de la concentraci\u00f3n de gases. Los sensores MQ requieren esperar un tiempo de calentamiento para que la salida sea estable y tenga las caracter\u00edsticas que el fabricante muestra en sus datasheet, dicho tiempo dependiendo del modelo puede variar entre 12 y 48 horas. En concreto en el datasheet del MQ-2 podemos ver que para este sensor se requieren alrededor de 24 horas. El sensor MQ-2 es adecuado para detectar hidr\u00f3geno, GLP, metano (CH4), Mon\u00f3xido de carbono (CO), alcohol, humo y propano (C3H8). Presenta su mayor sensibilidad a los GLP y al propano. El sensor de gas MQ-2 es anal\u00f3gico y se utiliza en la detecci\u00f3n de fugas de gas de equipos en los mercados de consumo y la industria, este sensor tiene una alta sensibilidad ajustable mediante el potenci\u00f3metro que incorpora el m\u00f3dulo, y un tiempo de respuesta r\u00e1pido. El aspecto del m\u00f3dulo sensor MQ-2 lo vemos en la Figura 3.11.2. Figura 3.11.2. Aspecto MQ-2 El sensor dispone de 4 pines, que son: VCC: Alimentaci\u00f3n positiva de 5V GND: Masa o 0V D0: Se conecta a un pin digital en estado alto y se encarga del calentamiento del sensor. A0: Salida anal\u00f3gica del sensor.","title":"Teor\u00eda"},{"location":"gas/#actividad-a10_1","text":"En esta actividad vamos a leer directamente el valor entregado por el sensor MQ-2 (pines 11 y A0) enviando los datos al terminal serie. La soluci\u00f3n la tenemos disponible en Smart-home-A10_1 . Figura 3.11.3. Soluci\u00f3n A10_1 En la Figura 3.11.4 vemos los resultados de la lectura en la consola serie y se aprecia el aumento en el aire de alg\u00fan gas y la disminuci\u00f3n cuando este se va disipando. Figura 3.11.4. Consola A10_1","title":"Actividad A10_1"},{"location":"gas/#actividad-a10_2","text":"En lugar de enviar los datos a la consola serie como en A10_1 los enviamos al Serial Plotter. La soluci\u00f3n la tenemos disponible en Smart-home-A10_2 . Figura 3.11.5. Soluci\u00f3n A10_2 En la Figura 3.11.6 vemos una captura del datalogger. Figura 3.11.6. Serial plotter A10_2","title":"Actividad A10_2"},{"location":"gas/#actividad-a10_3","text":"Montamos una alarma sonora por detecci\u00f3n de gas. La soluci\u00f3n la tenemos disponible en Smart-home-A10_3 . Figura 3.11.7. Soluci\u00f3n A10_3","title":"Actividad A10_3"},{"location":"humedad/","text":"3.13. A12-Sensor de humedad del suelo \u00b6 Teoria \u00b6 Este es un sensor anal\u00f3gico de humedad ideado para detectar la humedad del suelo. Si el suelo no est\u00e1 h\u00famedo, el valor anal\u00f3gico emitido por el sensor disminuir\u00e1, de lo contrario, aumentar\u00e1. Se puede usar este sensor para hacer un dispositivo de riego autom\u00e1tico que detecte si una planta necesita ser regada. Usar el sensor con una placa tipo Arduino hace que nuestra planta pertenezca a un jard\u00edn inteligente. El sensor se construye con dos sondas listas para ser insertadas en el suelo, y as\u00ed con la corriente que circula por el suelo, el sensor obtendr\u00e1 un valor de resistencia que le permite leer los cambios que se producen entre las dos sondas y convertir dicho valor de resistencia en contenido de humedad del suelo. Cuanto mayor sea la humedad (menos resistencia), mayor ser\u00e1 la conductividad del suelo. La superficie del sensor se ha metalizado para prolongar su vida \u00fatil. En la Figura 3.13.1 podemos ver el aspecto que tiene este sensor. Figura 3.13.1. Aspecto del sensor de humedad del suelo Sus principales especificaciones son: Alimentaci\u00f3n: 3.3 o 5V Consumo: \u2264 20mA Tensi\u00f3n de salida: de 0 a 2.3V (alimentado a 5V). La mayor tensi\u00f3n corresponde al sensor totalmente sumergido en agua. Tipo de salida: anal\u00f3gica. Vida \u00fatil: un a\u00f1o aproximadamente. Superficie: esta\u00f1ada para mejorar su conductividad y durabilidad Actividad A12_1 \u00b6 En esta actividad enviaremos a la LCD el valor detectado por el sensor de humedad de suelo conectado en A2. El programa final lo tenemos disponible en el enlace Smart-home-A12_1 . Figura 3.13.2. Soluci\u00f3n A12_1","title":"3.13. A12-Sensor de humedad del suelo"},{"location":"humedad/#313-a12-sensor-de-humedad-del-suelo","text":"","title":"3.13. A12-Sensor de humedad del suelo"},{"location":"humedad/#teoria","text":"Este es un sensor anal\u00f3gico de humedad ideado para detectar la humedad del suelo. Si el suelo no est\u00e1 h\u00famedo, el valor anal\u00f3gico emitido por el sensor disminuir\u00e1, de lo contrario, aumentar\u00e1. Se puede usar este sensor para hacer un dispositivo de riego autom\u00e1tico que detecte si una planta necesita ser regada. Usar el sensor con una placa tipo Arduino hace que nuestra planta pertenezca a un jard\u00edn inteligente. El sensor se construye con dos sondas listas para ser insertadas en el suelo, y as\u00ed con la corriente que circula por el suelo, el sensor obtendr\u00e1 un valor de resistencia que le permite leer los cambios que se producen entre las dos sondas y convertir dicho valor de resistencia en contenido de humedad del suelo. Cuanto mayor sea la humedad (menos resistencia), mayor ser\u00e1 la conductividad del suelo. La superficie del sensor se ha metalizado para prolongar su vida \u00fatil. En la Figura 3.13.1 podemos ver el aspecto que tiene este sensor. Figura 3.13.1. Aspecto del sensor de humedad del suelo Sus principales especificaciones son: Alimentaci\u00f3n: 3.3 o 5V Consumo: \u2264 20mA Tensi\u00f3n de salida: de 0 a 2.3V (alimentado a 5V). La mayor tensi\u00f3n corresponde al sensor totalmente sumergido en agua. Tipo de salida: anal\u00f3gica. Vida \u00fatil: un a\u00f1o aproximadamente. Superficie: esta\u00f1ada para mejorar su conductividad y durabilidad","title":"Teoria"},{"location":"humedad/#actividad-a12_1","text":"En esta actividad enviaremos a la LCD el valor detectado por el sensor de humedad de suelo conectado en A2. El programa final lo tenemos disponible en el enlace Smart-home-A12_1 . Figura 3.13.2. Soluci\u00f3n A12_1","title":"Actividad A12_1"},{"location":"intro/","text":"3.1. Introducci\u00f3n a los retos de programaci\u00f3n \u00b6 Aunque hemos realizado el montaje completo del kit smart home no lo vamos a programar de una sola vez, sino que vamos a plantear una serie de retos que comenzar\u00e1n desde lo m\u00e1s b\u00e1sico hasta la programaci\u00f3n de todos los elementos, incluido el control remoto desde un smartphone. Nuestro lenguaje de programaci\u00f3n va a ser ArduinoBlocks, un lenguaje visual por bloques muy potente y f\u00e1cil de usar. Tambi\u00e9n se puede trabajar con el kit utilizando el IDE de Arduino o el lenguaje visual Mixly que podemos descargar de Keyestudio. En los enlaces siguientes podemos encontrar mas informaci\u00f3n respecto al uso del programa. Descripci\u00f3n r\u00e1pida del uso del Software ArduinoBlocks . Conceptos sobre el uso de Operadores en C++ . Manuales de ArduinoBlocks Teor\u00eda b\u00e1sica de IoT . \u00bfC\u00f3mo se trabaja con ArduinoBlocks? \u00b6 Para empezar a trabajar con ArduinoBlocks, es necesario registrarse y crear un nuevo usuario. Debemos acceder al bot\u00f3n \"Iniciar sesi\u00f3n\" para despu\u00e9s, seleccionar la opci\u00f3n de nuevo usuario. En la Figura 3.1.1 vemos como acceder a la ventana de inicio de sesi\u00f3n. Figura 3.1.1. Acceso al inicio de sesi\u00f3n en ArduinoBlocks En la Figura 3.1.2 vemos la ventana de inicio de sesi\u00f3n. Figura 3.1.2. Inicio de sesi\u00f3n en ArduinoBlocks Seguidamente, se debe seleccionar \"Empezar un proyecto nuevo\". Como vemos en la Figura 3.1.3 nos aparecen tres opciones: proyecto personal, profesor o alumno. Figura 3.1.3. Empezar un proyecto nuevo Si escogemos el proyecto personal s\u00f3lo podremos acceder nosotros, pero despu\u00e9s lo podemos compartir si decidimos hacerlo p\u00fablico. En cambio, si seleccionamos el proyecto profesor, no se comienza un proyecto sino que se crea un c\u00f3digo para que los alumnos puedan inscribirse en el proyecto. De esta forma, el profesor puede supervisar las programaciones de sus estudiantes. Por \u00faltimo, la opci\u00f3n de alumno es para unirnos al proyecto planteado por el profesor. Para aprender mas sobre Usuarios Gestionados basta con acceder a la presentaci\u00f3n del enlace anterior. \u00bfC\u00f3mo es la interfaz de programaci\u00f3n de ArduinoBlocks? \u00b6 Una vez hemos escogido la opci\u00f3n de proyecto personal, nos pregunta qu\u00e9 placa estamos utilizando y qu\u00e9 nombre queremos dar a nuestro proyecto. A su vez, podemos a\u00f1adir informaci\u00f3n, como: descripci\u00f3n del proyecto, componentes que necesitamos y otras especificaciones en el apartado de comentarios. En nuestro caso escogeremos: Arduino Uno, tal y como vemos en la Figura 3.1.4, donde se aconseja la forma de nombrar los proyectos relacionados con este tema. Figura 3.1.4. Tipo de placa y nombre del proyecto Una vez ponemos nombre, y aunque es opcional se recomienda cumplimentar los distintos apartados, y hacemos clic en el bot\u00f3n \u201cNuevo proyecto\u201d entramos en el nuevo proyecto, nos encontramos con la pantalla que vemos en la Figura 3.1.5. Figura 3.1.5. Pantalla inicial de un proyecto Ya es posible guardar nuestros bloques favoritos de ArduinoBlocks en la mochila y llevarlos siempre con nosotros o usarla para compartir bloques entre nuestros proyectos. En este enlace tienes un video que lo explica de forma gr\u00e1fica. ArduinoBlocks Connector \u00b6 ArduinobBloks genera el c\u00f3digo de Arduino a partir de los bloques. El programa copia y sube nuestra programaci\u00f3n a la placa gracias a la aplicaci\u00f3n ArduinoBlocks Connector. Si no ejecutamos ArduinoBlocks Connector, podremos programar y acceder a la plataforma ArduionBlocks, pero no podremos subir nuestro programa a la placa. As\u00ed pues, es necesario instalarlo en nuestro ordenador, y ejecutarlo cuando hagamos uso de la plataforma. Actualmente (septiembre de 2022), est\u00e1 disponible la versi\u00f3n 5 para estos sistemas operativos: Windows, Ubuntu, MacOS, Chromebook y Raspberry Pi, tal y como se indica en la Figura 3.1.6. Figura 3.1.6. Disponibilidad de ArduinoBlocks para distintos sistemas operativos","title":"3.1. Introducci\u00f3n"},{"location":"intro/#31-introduccion-a-los-retos-de-programacion","text":"Aunque hemos realizado el montaje completo del kit smart home no lo vamos a programar de una sola vez, sino que vamos a plantear una serie de retos que comenzar\u00e1n desde lo m\u00e1s b\u00e1sico hasta la programaci\u00f3n de todos los elementos, incluido el control remoto desde un smartphone. Nuestro lenguaje de programaci\u00f3n va a ser ArduinoBlocks, un lenguaje visual por bloques muy potente y f\u00e1cil de usar. Tambi\u00e9n se puede trabajar con el kit utilizando el IDE de Arduino o el lenguaje visual Mixly que podemos descargar de Keyestudio. En los enlaces siguientes podemos encontrar mas informaci\u00f3n respecto al uso del programa. Descripci\u00f3n r\u00e1pida del uso del Software ArduinoBlocks . Conceptos sobre el uso de Operadores en C++ . Manuales de ArduinoBlocks Teor\u00eda b\u00e1sica de IoT .","title":"3.1. Introducci\u00f3n a los retos de programaci\u00f3n"},{"location":"intro/#como-se-trabaja-con-arduinoblocks","text":"Para empezar a trabajar con ArduinoBlocks, es necesario registrarse y crear un nuevo usuario. Debemos acceder al bot\u00f3n \"Iniciar sesi\u00f3n\" para despu\u00e9s, seleccionar la opci\u00f3n de nuevo usuario. En la Figura 3.1.1 vemos como acceder a la ventana de inicio de sesi\u00f3n. Figura 3.1.1. Acceso al inicio de sesi\u00f3n en ArduinoBlocks En la Figura 3.1.2 vemos la ventana de inicio de sesi\u00f3n. Figura 3.1.2. Inicio de sesi\u00f3n en ArduinoBlocks Seguidamente, se debe seleccionar \"Empezar un proyecto nuevo\". Como vemos en la Figura 3.1.3 nos aparecen tres opciones: proyecto personal, profesor o alumno. Figura 3.1.3. Empezar un proyecto nuevo Si escogemos el proyecto personal s\u00f3lo podremos acceder nosotros, pero despu\u00e9s lo podemos compartir si decidimos hacerlo p\u00fablico. En cambio, si seleccionamos el proyecto profesor, no se comienza un proyecto sino que se crea un c\u00f3digo para que los alumnos puedan inscribirse en el proyecto. De esta forma, el profesor puede supervisar las programaciones de sus estudiantes. Por \u00faltimo, la opci\u00f3n de alumno es para unirnos al proyecto planteado por el profesor. Para aprender mas sobre Usuarios Gestionados basta con acceder a la presentaci\u00f3n del enlace anterior.","title":"\u00bfC\u00f3mo se trabaja con ArduinoBlocks?"},{"location":"intro/#como-es-la-interfaz-de-programacion-de-arduinoblocks","text":"Una vez hemos escogido la opci\u00f3n de proyecto personal, nos pregunta qu\u00e9 placa estamos utilizando y qu\u00e9 nombre queremos dar a nuestro proyecto. A su vez, podemos a\u00f1adir informaci\u00f3n, como: descripci\u00f3n del proyecto, componentes que necesitamos y otras especificaciones en el apartado de comentarios. En nuestro caso escogeremos: Arduino Uno, tal y como vemos en la Figura 3.1.4, donde se aconseja la forma de nombrar los proyectos relacionados con este tema. Figura 3.1.4. Tipo de placa y nombre del proyecto Una vez ponemos nombre, y aunque es opcional se recomienda cumplimentar los distintos apartados, y hacemos clic en el bot\u00f3n \u201cNuevo proyecto\u201d entramos en el nuevo proyecto, nos encontramos con la pantalla que vemos en la Figura 3.1.5. Figura 3.1.5. Pantalla inicial de un proyecto Ya es posible guardar nuestros bloques favoritos de ArduinoBlocks en la mochila y llevarlos siempre con nosotros o usarla para compartir bloques entre nuestros proyectos. En este enlace tienes un video que lo explica de forma gr\u00e1fica.","title":"\u00bfC\u00f3mo es la interfaz de programaci\u00f3n de ArduinoBlocks?"},{"location":"intro/#arduinoblocks-connector","text":"ArduinobBloks genera el c\u00f3digo de Arduino a partir de los bloques. El programa copia y sube nuestra programaci\u00f3n a la placa gracias a la aplicaci\u00f3n ArduinoBlocks Connector. Si no ejecutamos ArduinoBlocks Connector, podremos programar y acceder a la plataforma ArduionBlocks, pero no podremos subir nuestro programa a la placa. As\u00ed pues, es necesario instalarlo en nuestro ordenador, y ejecutarlo cuando hagamos uso de la plataforma. Actualmente (septiembre de 2022), est\u00e1 disponible la versi\u00f3n 5 para estos sistemas operativos: Windows, Ubuntu, MacOS, Chromebook y Raspberry Pi, tal y como se indica en la Figura 3.1.6. Figura 3.1.6. Disponibilidad de ArduinoBlocks para distintos sistemas operativos","title":"ArduinoBlocks Connector"},{"location":"led/","text":"3.2. A01-Diodos LED \u00b6 Teoria sobre LEDs \u00b6 El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores PWM \u00b6 PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emulan una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. La placa KS0486 Keyestudio PLUS es de tipo UNO y dispone de seis salidas PWM (D3, D5, D6, D9, D10 y D11). Actividad A01_1 \u00b6 En esta actividad encenderemos y apagaremos cada dos segundos el led blanco que tenemos conectado al pin D13. El programa final queda como vemos en la Figura 3.2.1 y lo tenemos disponible en el enlace Smart-home-A01_1 . Figura 3.2.1. Soluci\u00f3n A01_1 Actividad A01_2 \u00b6 En esta actividad apagaremos y encenderemos de forma progresiva el LED amarillo que tenemos conectado en D5. Utilizaremos la t\u00e9cnica del PWM que ya viene implementada para ese pin. El programa final queda como vemos en la Figura 3.2.2 y lo tenemos disponible en el enlace Smart-home-A01_2 . Figura 3.2.2. Soluci\u00f3n A01_2","title":"3.2. A01-Diodos LED"},{"location":"led/#32-a01-diodos-led","text":"","title":"3.2. A01-Diodos LED"},{"location":"led/#teoria-sobre-leds","text":"El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores","title":"Teoria sobre LEDs"},{"location":"led/#pwm","text":"PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emulan una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. La placa KS0486 Keyestudio PLUS es de tipo UNO y dispone de seis salidas PWM (D3, D5, D6, D9, D10 y D11).","title":"PWM"},{"location":"led/#actividad-a01_1","text":"En esta actividad encenderemos y apagaremos cada dos segundos el led blanco que tenemos conectado al pin D13. El programa final queda como vemos en la Figura 3.2.1 y lo tenemos disponible en el enlace Smart-home-A01_1 . Figura 3.2.1. Soluci\u00f3n A01_1","title":"Actividad A01_1"},{"location":"led/#actividad-a01_2","text":"En esta actividad apagaremos y encenderemos de forma progresiva el LED amarillo que tenemos conectado en D5. Utilizaremos la t\u00e9cnica del PWM que ya viene implementada para ese pin. El programa final queda como vemos en la Figura 3.2.2 y lo tenemos disponible en el enlace Smart-home-A01_2 . Figura 3.2.2. Soluci\u00f3n A01_2","title":"Actividad A01_2"},{"location":"movimiento/","text":"5.2. Reto 2 - Alarma por movimiento \u00b6 A\u00f1adir al reto 1 la alarma si el sensor PIR detecta movimiento. Se muestra informaci\u00f3n en la pantalla LCD del nivel de gas detectado. En la Figura 5.2.1 vemos el programa en ArduinoBlocks. Figura 5.2.1. Soluci\u00f3n Reto 2 En la visualizaci\u00f3n en pantalla los valores de gas se muestran en tanto por ciento y para el sensor PIR se indica su estado l\u00f3gico: '0' cuando no est\u00e1 activado y '1' cuando est\u00e1 activado. En el enlace Smart-home-Reto2 tenemos el programa listo para verlo y traerlo a nuestros proyectos. Si preferimos descargar el proyecto a nuestro ordenador, desde el archivo Smart-home-Reto2.abp podemos hacerlo para posteriormente importarlo.","title":"5.2. Reto 2 - Alarma por movimiento"},{"location":"movimiento/#52-reto-2-alarma-por-movimiento","text":"A\u00f1adir al reto 1 la alarma si el sensor PIR detecta movimiento. Se muestra informaci\u00f3n en la pantalla LCD del nivel de gas detectado. En la Figura 5.2.1 vemos el programa en ArduinoBlocks. Figura 5.2.1. Soluci\u00f3n Reto 2 En la visualizaci\u00f3n en pantalla los valores de gas se muestran en tanto por ciento y para el sensor PIR se indica su estado l\u00f3gico: '0' cuando no est\u00e1 activado y '1' cuando est\u00e1 activado. En el enlace Smart-home-Reto2 tenemos el programa listo para verlo y traerlo a nuestros proyectos. Si preferimos descargar el proyecto a nuestro ordenador, desde el archivo Smart-home-Reto2.abp podemos hacerlo para posteriormente importarlo.","title":"5.2. Reto 2 - Alarma por movimiento"},{"location":"pir/","text":"3.10. A09-Sensor de movimiento PIR \u00b6 Teor\u00eda 3.11. A10-Sensor de gas MQ-2 \u00b6 Los detectores PIR (del ing\u00e9s Passive Infrared), se caracterizan por su reducido tama\u00f1o, bajo costo, no ser influenciados por la luz natural, tener un bajo consumo de energ\u00eda y ser de muy f\u00e1cil manejo. Reaccionan s\u00f3lo ante determinadas fuentes de energ\u00eda tales como la generada por el calor del cuerpo humano o de los animales. Basan su funcionamiento en que todos los cuerpos (especialmente los vivos) emiten una cierta cantidad de energ\u00eda infrarroja, mayor cuanto mayor es su temperatura que la capta un sensor piro el\u00e9ctrico y la convierte en una se\u00f1al el\u00e9ctrica. Los detectores PIR son dispositivos que detectan variaciones de la radiaci\u00f3n infrarroja en su \u00e1rea de cobertura, por lo que son especialmente \u00fatiles para detectar la presencia de personas o animales a trav\u00e9s del calor que emiten sus cuerpos. Aunque en el enunciado del apartado pone \"Sensor de movimiento PIR\", el concepto PIR es solamente uno de los m\u00e9todos posibles de detecci\u00f3n de movimiento, pero es el que nos ocupa y en proyectos con placas tipo Arduino es muy com\u00fan asociar ambos conceptos. Los sensores PIR son mas complicados de explicar que la mayor\u00eda de sensores (fotoc\u00e9lulas, sensores de golpe, etc) porque hay muchas variables que afectan a la entrada y salida del sensor. Para explicar de forma sencilla como trabaja el sensor nos vamos a basar en el diagrama de la Figura 3.10.1 Figura 3.10.1. Explicaci\u00f3n sensor PIR El sensor PIR en s\u00ed tiene dos ranuras, cada ranura est\u00e1 hecha de un material especial que es sensible a los infrarrojos. La lente utilizada aqu\u00ed realmente no est\u00e1 haciendo mucho, por lo que vemos que las dos ranuras pueden 'ver' m\u00e1s all\u00e1 de cierta distancia (b\u00e1sicamente, la sensibilidad del sensor). Cuando el sensor est\u00e1 inactivo, ambas ranuras detectan la misma cantidad de infrarrojos, la cantidad ambiental radiada desde la habitaci\u00f3n, las paredes o el exterior. Cuando pasa un cuerpo caliente como por ejemplo una persona o un animal, primero intercepta la mitad del sensor PIR, lo que provoca un cambio diferencial positivo entre las dos mitades. Cuando el cuerpo caliente sale del \u00e1rea de detecci\u00f3n, ocurre lo contrario, por lo que el sensor genera un cambio diferencial negativo. Estos pulsos de cambio son lo que se detectan. El sensor IR en s\u00ed est\u00e1 dentro de una caja met\u00e1lica sellada herm\u00e9ticamente para mejorar la inmunidad al ruido/temperatura/humedad. Esta caja dispone de una ventana hecha de material transmisor de infrarrojos (t\u00edpicamente silicona recubierta) que protege el elemento sensor con los dos sensores equilibrados. La mayor parte de la verdadera magia ocurre con la \u00f3ptica, una lente de Fresnel que permite cambiar la amplitud, el rango y el patr\u00f3n de detecci\u00f3n muy f\u00e1cilmente. Seg\u00fan la Wikipedia es un dise\u00f1o que permite construir lentes de gran apertura y distancia focal corta con materiales ligeros y econ\u00f3micos. En la Figura 3.10.2 vemos un corte transversal de una lente de Fresnel comparada con una plano-convexa tradicional. Figura 3.10.2. Lentes de Fresnel y convexa En la Figura 3.10.3 vemos gr\u00e1ficamente el funcionamiento del sistema y como la lente Fresnel condensa la radiaci\u00f3n infrarroja al sensor. Figura 3.10.3. Funcionamiento de una lente Fresnel Explicaci\u00f3n del funcionamiento basada en en el documento de Adafruit titulado PIR Motion Sensor - Created by lady ada En la Figura 3.10.4 vemos la ventan del sensor PIR en el m\u00f3dulo que incorpora la Smart home. Figura 3.10.4. Ventana del sensor PIR en el m\u00f3dulo de Keyestudio Las caracter\u00edsticas del m\u00f3dulo de keyestudio son: Tensi\u00f3n de alimentaci\u00f3n: de 3.3 a 18V DC Consumo 15 uA Temperatura de trabajo: de -20 a 85 \u00baC Salidas: 3V = nivel alto y 0V = nivel bajo Tiempo de retardo en la salida para el nivel alto: 2.3 a 3 segundos \u00c1ngulo de detecci\u00f3n: 100\u00ba Distancia de detecci\u00f3n: 3 a 4 metros LED indicador: Si la salida est\u00e1 en nivel alto el LED se enciende Algunas aclaraciones que nos hace el fabricante: La distancia m\u00e1xima es de 3-4 metros. Antes de probar la primera vez quitamos la lente blanca, se puede ver la ventana de detecci\u00f3n rectangular. Cuando el lado mayor del rect\u00e1ngulo es paralelo al suelo, la distancia es la mejor. Para comenzar a probar el sensor debe cubrirse con la lente blanca; de lo contrario, afectar\u00e1 a la distancia. La distancia de detecci\u00f3n \u00f3ptima se da a 25 \u2103 y se acorta cuando supera los 30 \u2103. Cuando carguemos nuestro c\u00f3digo debemos esperar entre 5 a 10 segundos para que el m\u00f3dulo sea sensible y luego comenzar a probar. Actividad A09_1 \u00b6 En esta actividad vamos a hacer que cuando el sensor PIR (pin 2) detecte una presencia suene una alarma ac\u00fastica en el zumbador (pin 3) y que alternativamente parpadeen los diodos LED amarillo (pin 5) y blanco (pin 13). La soluci\u00f3n la tenemos disponible en Smart-home-A09_1 . Figura 3.10.5. Soluci\u00f3n A09_1","title":"3.10. A09-Sensor de movimiento PIR"},{"location":"pir/#310-a09-sensor-de-movimiento-pir","text":"","title":"3.10. A09-Sensor de movimiento PIR"},{"location":"pir/#teoria311-a10-sensor-de-gas-mq-2","text":"Los detectores PIR (del ing\u00e9s Passive Infrared), se caracterizan por su reducido tama\u00f1o, bajo costo, no ser influenciados por la luz natural, tener un bajo consumo de energ\u00eda y ser de muy f\u00e1cil manejo. Reaccionan s\u00f3lo ante determinadas fuentes de energ\u00eda tales como la generada por el calor del cuerpo humano o de los animales. Basan su funcionamiento en que todos los cuerpos (especialmente los vivos) emiten una cierta cantidad de energ\u00eda infrarroja, mayor cuanto mayor es su temperatura que la capta un sensor piro el\u00e9ctrico y la convierte en una se\u00f1al el\u00e9ctrica. Los detectores PIR son dispositivos que detectan variaciones de la radiaci\u00f3n infrarroja en su \u00e1rea de cobertura, por lo que son especialmente \u00fatiles para detectar la presencia de personas o animales a trav\u00e9s del calor que emiten sus cuerpos. Aunque en el enunciado del apartado pone \"Sensor de movimiento PIR\", el concepto PIR es solamente uno de los m\u00e9todos posibles de detecci\u00f3n de movimiento, pero es el que nos ocupa y en proyectos con placas tipo Arduino es muy com\u00fan asociar ambos conceptos. Los sensores PIR son mas complicados de explicar que la mayor\u00eda de sensores (fotoc\u00e9lulas, sensores de golpe, etc) porque hay muchas variables que afectan a la entrada y salida del sensor. Para explicar de forma sencilla como trabaja el sensor nos vamos a basar en el diagrama de la Figura 3.10.1 Figura 3.10.1. Explicaci\u00f3n sensor PIR El sensor PIR en s\u00ed tiene dos ranuras, cada ranura est\u00e1 hecha de un material especial que es sensible a los infrarrojos. La lente utilizada aqu\u00ed realmente no est\u00e1 haciendo mucho, por lo que vemos que las dos ranuras pueden 'ver' m\u00e1s all\u00e1 de cierta distancia (b\u00e1sicamente, la sensibilidad del sensor). Cuando el sensor est\u00e1 inactivo, ambas ranuras detectan la misma cantidad de infrarrojos, la cantidad ambiental radiada desde la habitaci\u00f3n, las paredes o el exterior. Cuando pasa un cuerpo caliente como por ejemplo una persona o un animal, primero intercepta la mitad del sensor PIR, lo que provoca un cambio diferencial positivo entre las dos mitades. Cuando el cuerpo caliente sale del \u00e1rea de detecci\u00f3n, ocurre lo contrario, por lo que el sensor genera un cambio diferencial negativo. Estos pulsos de cambio son lo que se detectan. El sensor IR en s\u00ed est\u00e1 dentro de una caja met\u00e1lica sellada herm\u00e9ticamente para mejorar la inmunidad al ruido/temperatura/humedad. Esta caja dispone de una ventana hecha de material transmisor de infrarrojos (t\u00edpicamente silicona recubierta) que protege el elemento sensor con los dos sensores equilibrados. La mayor parte de la verdadera magia ocurre con la \u00f3ptica, una lente de Fresnel que permite cambiar la amplitud, el rango y el patr\u00f3n de detecci\u00f3n muy f\u00e1cilmente. Seg\u00fan la Wikipedia es un dise\u00f1o que permite construir lentes de gran apertura y distancia focal corta con materiales ligeros y econ\u00f3micos. En la Figura 3.10.2 vemos un corte transversal de una lente de Fresnel comparada con una plano-convexa tradicional. Figura 3.10.2. Lentes de Fresnel y convexa En la Figura 3.10.3 vemos gr\u00e1ficamente el funcionamiento del sistema y como la lente Fresnel condensa la radiaci\u00f3n infrarroja al sensor. Figura 3.10.3. Funcionamiento de una lente Fresnel Explicaci\u00f3n del funcionamiento basada en en el documento de Adafruit titulado PIR Motion Sensor - Created by lady ada En la Figura 3.10.4 vemos la ventan del sensor PIR en el m\u00f3dulo que incorpora la Smart home. Figura 3.10.4. Ventana del sensor PIR en el m\u00f3dulo de Keyestudio Las caracter\u00edsticas del m\u00f3dulo de keyestudio son: Tensi\u00f3n de alimentaci\u00f3n: de 3.3 a 18V DC Consumo 15 uA Temperatura de trabajo: de -20 a 85 \u00baC Salidas: 3V = nivel alto y 0V = nivel bajo Tiempo de retardo en la salida para el nivel alto: 2.3 a 3 segundos \u00c1ngulo de detecci\u00f3n: 100\u00ba Distancia de detecci\u00f3n: 3 a 4 metros LED indicador: Si la salida est\u00e1 en nivel alto el LED se enciende Algunas aclaraciones que nos hace el fabricante: La distancia m\u00e1xima es de 3-4 metros. Antes de probar la primera vez quitamos la lente blanca, se puede ver la ventana de detecci\u00f3n rectangular. Cuando el lado mayor del rect\u00e1ngulo es paralelo al suelo, la distancia es la mejor. Para comenzar a probar el sensor debe cubrirse con la lente blanca; de lo contrario, afectar\u00e1 a la distancia. La distancia de detecci\u00f3n \u00f3ptima se da a 25 \u2103 y se acorta cuando supera los 30 \u2103. Cuando carguemos nuestro c\u00f3digo debemos esperar entre 5 a 10 segundos para que el m\u00f3dulo sea sensible y luego comenzar a probar.","title":"Teor\u00eda3.11. A10-Sensor de gas MQ-2"},{"location":"pir/#actividad-a09_1","text":"En esta actividad vamos a hacer que cuando el sensor PIR (pin 2) detecte una presencia suene una alarma ac\u00fastica en el zumbador (pin 3) y que alternativamente parpadeen los diodos LED amarillo (pin 5) y blanco (pin 13). La soluci\u00f3n la tenemos disponible en Smart-home-A09_1 . Figura 3.10.5. Soluci\u00f3n A09_1","title":"Actividad A09_1"},{"location":"placas/","text":"2.3. Placas KS0486 PLUS y Ks0004 Sensor Shield V5.2 \u00b6 2.3.1. Placa de desarrollo KS0486 Keyestudio PLUS \u00b6 Esta placa de control es totalmente compatible y contiene todas las funciones de las placas tipo Arduino UNO R3. Adem\u00e1s, dispone de las mejoras que vemos en la comparativa siguiente. Para estar actualizada la placa se ha equipado con un cable USB de 1 m con interfaz tipo C. Comparativa 2.3.2. Placa Ks0004 Keyestudio Sensor Shield V5 \u00b6 Esta placa amplia los puertos digitales y anal\u00f3gicos con interfaz de 3 pines (G, V, S) a los que se pueden conectar directamente m\u00f3dulos sensores de 3 pines. Tambi\u00e9n integra pines de comunicaci\u00f3n serie, IIC y SPI. Tambi\u00e9n lleva un bot\u00f3n de reinicio y 2 LEDs indicadores. Adem\u00e1s, se le puede suministrar el voltaje necesario para m\u00f3dulos que lo requieran a trav\u00e9s de la clema azul. En la imagen siguiente vemos el pinout de la placa. Pinout. Obtenido de","title":"2.3. Placas KS0486 PLUS y Ks0004 Sensor Shield V5.2"},{"location":"placas/#23-placas-ks0486-plus-y-ks0004-sensor-shield-v52","text":"","title":"2.3. Placas KS0486 PLUS y Ks0004 Sensor Shield V5.2"},{"location":"placas/#231-placa-de-desarrollo-ks0486-keyestudio-plus","text":"Esta placa de control es totalmente compatible y contiene todas las funciones de las placas tipo Arduino UNO R3. Adem\u00e1s, dispone de las mejoras que vemos en la comparativa siguiente. Para estar actualizada la placa se ha equipado con un cable USB de 1 m con interfaz tipo C. Comparativa","title":"2.3.1. Placa de desarrollo KS0486 Keyestudio PLUS"},{"location":"placas/#232-placa-ks0004-keyestudio-sensor-shield-v5","text":"Esta placa amplia los puertos digitales y anal\u00f3gicos con interfaz de 3 pines (G, V, S) a los que se pueden conectar directamente m\u00f3dulos sensores de 3 pines. Tambi\u00e9n integra pines de comunicaci\u00f3n serie, IIC y SPI. Tambi\u00e9n lleva un bot\u00f3n de reinicio y 2 LEDs indicadores. Adem\u00e1s, se le puede suministrar el voltaje necesario para m\u00f3dulos que lo requieran a trav\u00e9s de la clema azul. En la imagen siguiente vemos el pinout de la placa. Pinout. Obtenido de","title":"2.3.2. Placa Ks0004 Keyestudio Sensor Shield V5"},{"location":"pulsador/","text":"3.4. A03-Pulsador \u00b6 Teor\u00eda \u00b6 En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa UNO. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador Concepto de variable y de contador \u00b6 El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ... Condicionales \u00b6 Las sentencias condicionales son aquellas que nos permiten tomar decisiones en funci\u00f3n de si ocurre o no ocurre determinada cosa. En el caso de ArduinoBlocks estas las podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloque l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. L\u00f3gicamente el resultado de evaluar la condici\u00f3n debe ser verdadero o falso lo que se resuelve en el caso de la programaci\u00f3n en Arduino diciendo que si el resultado es 0, el resultado de la evaluciaci\u00f3n es falso y si es 1 o cualquier otro valor es verdero. Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\". Actividad A03_1 \u00b6 En esta actividad haremos un sencillo programa que encienda el LED amarillo (D5) cuando pulsemos el pulsador de la izquierda (D4). En la Figura 3.4.1 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A03_1 . Figura 3.4.1. Soluci\u00f3n A03_1 Actividad A03_2 \u00b6 En esta actividad haremos el mismo programa que en la anterior, pero utilizando la clausula else. En la Figura 3.4.2 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A03_2 . Figura 3.4.2. Soluci\u00f3n A03_2 Actividad A03_3 \u00b6 Resolver la actividad A03_2 de forma que el funcionamiento sea al contrario, es decir, que el LED amarillo est\u00e9 siempre encendido y al accionar el pulsador izquierdo se apague. La soluci\u00f3n la tenemos disponible en Smart-home-A03_3 . Figura 3.4.3. Soluci\u00f3n A03_3 Actividad A03_4 \u00b6 Hacer un programa que al accionar el pulsador izquierdo se encienda el LED amarillo y que al accionar el pulsador derecho (8) se apague. Como ampliaci\u00f3n se sugiere modificar el programa para que encienda y apague los dos LEDs blanco y amarillo a un tiempo o de forma alternada. La soluci\u00f3n la tenemos disponible en Smart-home-A03_4 . La soluci\u00f3n en esta ocasi\u00f3n est\u00e1 en utilizar el operador NOT y el operador AND. Para obtener mas informaci\u00f3n sobre operadores l\u00f3gicos podemos ir al enlace. Figura 3.4.4. Soluci\u00f3n A03_4 Actividad A03_5 \u00b6 Hacer un programa que emita, usando uno de los pulsadores como si fuese un tel\u00e9grafo, el c\u00f3digo Morse universal de solicitud de socorro, SOS. El alfabeto Morse lo vemos en la Figura 3.4.5, donde podemos observar que la S son tres puntos o pulsaciones cortas y la O son tres rayas o pulsaciones largas. Sin entrar en mas detalles daremos la soluci\u00f3n considerando SOS como una palabra (es lo universalmente adoptado) de forma que no haremos pausas entre letras. Figura 3.4.5. Alfabeto Morse La soluci\u00f3n la tenemos disponible en Smart-home-A03_5 . Figura 3.4.6. Soluci\u00f3n A03_5 Actividad A03_6 \u00b6 Hacer un programa que al accionar el pulsador izquierdo encienda el LED amarillo y que este permanezca encendido hasta que no accionemos el mismo pulsador dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1. La soluci\u00f3n la tenemos disponible en Smart-home-A03_6 . Figura 3.4.7. Soluci\u00f3n A03_6","title":"3.4. A03-Pulsador"},{"location":"pulsador/#34-a03-pulsador","text":"","title":"3.4. A03-Pulsador"},{"location":"pulsador/#teoria","text":"En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa UNO. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador","title":"Teor\u00eda"},{"location":"pulsador/#concepto-de-variable-y-de-contador","text":"El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ...","title":"Concepto de variable y de contador"},{"location":"pulsador/#condicionales","text":"Las sentencias condicionales son aquellas que nos permiten tomar decisiones en funci\u00f3n de si ocurre o no ocurre determinada cosa. En el caso de ArduinoBlocks estas las podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloque l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. L\u00f3gicamente el resultado de evaluar la condici\u00f3n debe ser verdadero o falso lo que se resuelve en el caso de la programaci\u00f3n en Arduino diciendo que si el resultado es 0, el resultado de la evaluciaci\u00f3n es falso y si es 1 o cualquier otro valor es verdero. Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\".","title":"Condicionales"},{"location":"pulsador/#actividad-a03_1","text":"En esta actividad haremos un sencillo programa que encienda el LED amarillo (D5) cuando pulsemos el pulsador de la izquierda (D4). En la Figura 3.4.1 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A03_1 . Figura 3.4.1. Soluci\u00f3n A03_1","title":"Actividad A03_1"},{"location":"pulsador/#actividad-a03_2","text":"En esta actividad haremos el mismo programa que en la anterior, pero utilizando la clausula else. En la Figura 3.4.2 vemos el programa completo. La soluci\u00f3n la tenemos disponible en Smart-home-A03_2 . Figura 3.4.2. Soluci\u00f3n A03_2","title":"Actividad A03_2"},{"location":"pulsador/#actividad-a03_3","text":"Resolver la actividad A03_2 de forma que el funcionamiento sea al contrario, es decir, que el LED amarillo est\u00e9 siempre encendido y al accionar el pulsador izquierdo se apague. La soluci\u00f3n la tenemos disponible en Smart-home-A03_3 . Figura 3.4.3. Soluci\u00f3n A03_3","title":"Actividad A03_3"},{"location":"pulsador/#actividad-a03_4","text":"Hacer un programa que al accionar el pulsador izquierdo se encienda el LED amarillo y que al accionar el pulsador derecho (8) se apague. Como ampliaci\u00f3n se sugiere modificar el programa para que encienda y apague los dos LEDs blanco y amarillo a un tiempo o de forma alternada. La soluci\u00f3n la tenemos disponible en Smart-home-A03_4 . La soluci\u00f3n en esta ocasi\u00f3n est\u00e1 en utilizar el operador NOT y el operador AND. Para obtener mas informaci\u00f3n sobre operadores l\u00f3gicos podemos ir al enlace. Figura 3.4.4. Soluci\u00f3n A03_4","title":"Actividad A03_4"},{"location":"pulsador/#actividad-a03_5","text":"Hacer un programa que emita, usando uno de los pulsadores como si fuese un tel\u00e9grafo, el c\u00f3digo Morse universal de solicitud de socorro, SOS. El alfabeto Morse lo vemos en la Figura 3.4.5, donde podemos observar que la S son tres puntos o pulsaciones cortas y la O son tres rayas o pulsaciones largas. Sin entrar en mas detalles daremos la soluci\u00f3n considerando SOS como una palabra (es lo universalmente adoptado) de forma que no haremos pausas entre letras. Figura 3.4.5. Alfabeto Morse La soluci\u00f3n la tenemos disponible en Smart-home-A03_5 . Figura 3.4.6. Soluci\u00f3n A03_5","title":"Actividad A03_5"},{"location":"pulsador/#actividad-a03_6","text":"Hacer un programa que al accionar el pulsador izquierdo encienda el LED amarillo y que este permanezca encendido hasta que no accionemos el mismo pulsador dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1. La soluci\u00f3n la tenemos disponible en Smart-home-A03_6 . Figura 3.4.7. Soluci\u00f3n A03_6","title":"Actividad A03_6"},{"location":"rele/","text":"3.5. A04-Rel\u00e9s \u00b6 Teor\u00eda \u00b6 Un rel\u00e9 es b\u00e1sicamente un interruptor mec\u00e1nico controlado el\u00e9ctricamente de forma que a trav\u00e9s de una peque\u00f1a tensi\u00f3n y corriente se puede controlar la apertura y cierre de sus contactos mec\u00e1nicos donde se puede trabajar con tensiones y corrientes elevadas. El m\u00f3dulo incluye un LED que nos indica si el rel\u00e9 est\u00e1 accionado cuando se enciende. El modelo de rel\u00e9 que lleva este m\u00f3dulo es el SRD-05VDC-SL-C que presenta las siguientes caracter\u00edsticas: En AC (corriente alterna): 250Vac / 10A En DC (corriente continua): 30Vdc / 10A o bien 250Vdc / 1A Tensi\u00f3n de la bobina: 5V, compatible con se\u00f1ales TTL para su excitaci\u00f3n Contactos: 3 pines, 1 Com\u00fan + 1 contacto NA (normalmente abierto) + 1 contacto NC (normalmente cerrado). Esquem\u00e1ticamente un rel\u00e9 de este tipo se puede parecer a la imagen siguiente: Un rel\u00e9 esquematizado Fuente: wikipedia En el enlace a wikipedia podemos ver una animaci\u00f3n del funcionamiento de un rel\u00e9 . Su aspecto es: Aspecto real del m\u00f3dulo rel\u00e9 En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\". Aspecto real del m\u00f3dulo rel\u00e9 En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\". Bloque de programaci\u00f3n del m\u00f3dulo rel\u00e9 El terminal o consola serie \u00b6 Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en ArduinoBlocks A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa UNO y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad es de 9600 baudios o bits por segundo y otras velocidades comunmente utilizadas son: 4800, 19200, 38400, 57600, 115200. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n. Serial Plotter - Datalogger \u00b6 Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger Mapeo \u00b6 Las entradas anal\u00f3gicas trabajan con 10 bits, o sea valores comprendidos entre 0 y 1023 y tambi\u00e9n que la salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255, por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa Matem\u00e1ticas con el aspecto de la imagen siguiente: Bloque mapear Este bloque permite modificar un valor o variable desde un rango origen a un rango destino. Esta funci\u00f3n es especialmente \u00fatil para adaptar los valores le\u00eddos de sensores o para adaptar valores a aplicar en un actuador. Actividad A04_1 \u00b6 Esta actividad va a consistir sencillamente en activar y desactivar el rel\u00e9 lo que originar\u00e1 un cambio en la posici\u00f3n de sus contactos. La forma de visualizar que funciona puede ser colocar un diodo LED entre el com\u00fan y uno de los contactos, medir continuidad con un pol\u00edmetro o colocar en los contactos cualquier otro elemento que nos permita observar que el rel\u00e9 cambia de estado. Si prestamos atenci\u00f3n podemos escuchar actuar los contactos. La soluci\u00f3n la tenemos disponible en Smart-home-A04_1 . Figura 3.5.1. Soluci\u00f3n A04_1 Actividad A04_2 \u00b6 Vamos a controlar el accionamiento de un rel\u00e9 desde nuestro ordenador a trav\u00e9s de la consola serie utilizando los siguientes comandos, que enviaremos desde la consola: 1 \u2013> ON, 2 \u2013> OFF y 3 \u2013> Conmutar ON/OFF a 500 ms. La soluci\u00f3n la tenemos disponible en Smart-home-A04_2 . Figura 3.5.2. Soluci\u00f3n A04_2 El aspecto de la consola lista para enviar el comando de encendido lo vemos en la Figura 3.5.3. Figura 3.5.3. Aspecto de la consola lista para enviar el comando 1","title":"3.5. A04-Rel\u00e9s"},{"location":"rele/#35-a04-reles","text":"","title":"3.5. A04-Rel\u00e9s"},{"location":"rele/#teoria","text":"Un rel\u00e9 es b\u00e1sicamente un interruptor mec\u00e1nico controlado el\u00e9ctricamente de forma que a trav\u00e9s de una peque\u00f1a tensi\u00f3n y corriente se puede controlar la apertura y cierre de sus contactos mec\u00e1nicos donde se puede trabajar con tensiones y corrientes elevadas. El m\u00f3dulo incluye un LED que nos indica si el rel\u00e9 est\u00e1 accionado cuando se enciende. El modelo de rel\u00e9 que lleva este m\u00f3dulo es el SRD-05VDC-SL-C que presenta las siguientes caracter\u00edsticas: En AC (corriente alterna): 250Vac / 10A En DC (corriente continua): 30Vdc / 10A o bien 250Vdc / 1A Tensi\u00f3n de la bobina: 5V, compatible con se\u00f1ales TTL para su excitaci\u00f3n Contactos: 3 pines, 1 Com\u00fan + 1 contacto NA (normalmente abierto) + 1 contacto NC (normalmente cerrado). Esquem\u00e1ticamente un rel\u00e9 de este tipo se puede parecer a la imagen siguiente: Un rel\u00e9 esquematizado Fuente: wikipedia En el enlace a wikipedia podemos ver una animaci\u00f3n del funcionamiento de un rel\u00e9 . Su aspecto es: Aspecto real del m\u00f3dulo rel\u00e9 En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\". Aspecto real del m\u00f3dulo rel\u00e9 En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\". Bloque de programaci\u00f3n del m\u00f3dulo rel\u00e9","title":"Teor\u00eda"},{"location":"rele/#el-terminal-o-consola-serie","text":"Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en ArduinoBlocks A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa UNO y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad es de 9600 baudios o bits por segundo y otras velocidades comunmente utilizadas son: 4800, 19200, 38400, 57600, 115200. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n.","title":"El terminal o consola serie"},{"location":"rele/#serial-plotter-datalogger","text":"Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger","title":"Serial Plotter - Datalogger"},{"location":"rele/#mapeo","text":"Las entradas anal\u00f3gicas trabajan con 10 bits, o sea valores comprendidos entre 0 y 1023 y tambi\u00e9n que la salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255, por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa Matem\u00e1ticas con el aspecto de la imagen siguiente: Bloque mapear Este bloque permite modificar un valor o variable desde un rango origen a un rango destino. Esta funci\u00f3n es especialmente \u00fatil para adaptar los valores le\u00eddos de sensores o para adaptar valores a aplicar en un actuador.","title":"Mapeo"},{"location":"rele/#actividad-a04_1","text":"Esta actividad va a consistir sencillamente en activar y desactivar el rel\u00e9 lo que originar\u00e1 un cambio en la posici\u00f3n de sus contactos. La forma de visualizar que funciona puede ser colocar un diodo LED entre el com\u00fan y uno de los contactos, medir continuidad con un pol\u00edmetro o colocar en los contactos cualquier otro elemento que nos permita observar que el rel\u00e9 cambia de estado. Si prestamos atenci\u00f3n podemos escuchar actuar los contactos. La soluci\u00f3n la tenemos disponible en Smart-home-A04_1 . Figura 3.5.1. Soluci\u00f3n A04_1","title":"Actividad A04_1"},{"location":"rele/#actividad-a04_2","text":"Vamos a controlar el accionamiento de un rel\u00e9 desde nuestro ordenador a trav\u00e9s de la consola serie utilizando los siguientes comandos, que enviaremos desde la consola: 1 \u2013> ON, 2 \u2013> OFF y 3 \u2013> Conmutar ON/OFF a 500 ms. La soluci\u00f3n la tenemos disponible en Smart-home-A04_2 . Figura 3.5.2. Soluci\u00f3n A04_2 El aspecto de la consola lista para enviar el comando de encendido lo vemos en la Figura 3.5.3. Figura 3.5.3. Aspecto de la consola lista para enviar el comando 1","title":"Actividad A04_2"},{"location":"servo/","text":"3.7. A06-Servomotores \u00b6 Teor\u00eda \u00b6 Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesita alimentaci\u00f3n ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control. Los servomotores son en realidad motores de corriente continua a los que se les ha a\u00f1adido una reductora, para que giren m\u00e1s despacio y con m\u00e1s fuerza, y un controlador electr\u00f3nico que permite hacer que gire un determinado \u00e1ngulo. Adem\u00e1s, el servo en todo momento sabe en qu\u00e9 posici\u00f3n est\u00e1, aunque se apague o reinicie. Esto significa que si a un servo que hemos movido a un determinado punto, lo hemos dejado sin alimentaci\u00f3n y al alimentarlo de nuevo le indicamos que gire 90\u00ba, no va a girar 90\u00ba sino que se va a dirigir a su posici\u00f3n de 90\u00ba que tiene memorizada internamente. En la Figura 3.7.1 vemos el interior de un servo esquematizado. Figura 3.7.1. Interior de un servo 9g Su aspecto real lo vemos en la Figura 3.7.2 donde tambi\u00e9n se aprecian las palas y tornilleria que lo acompa\u00f1an. Figura 3.7.2. Aspecto real servo 9g Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados. El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores). El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz). Hay que tener mucho cuidado de posicionar el conector de los servos en los tres pines macho de la shield en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irremediable. Existe un tipo especial de servomotor que permite la rotaci\u00f3n continua. En algunos casos se trata de servomotores \u201ctrucados\u201d de forma que se modifican para permitir la rotaci\u00f3n continua quitando los topes mec\u00e1nicos y se sustituye el potenci\u00f3metro por un divisor de tensi\u00f3n con dos resistencia iguales (en algunos casos no se ponen resistencias y se bloquea el potenci\u00f3metro para que no gire dej\u00e1ndolo justo en su punto central). Este tipo de modificaci\u00f3n la podemos realizar nosotros (en la web existen multitud de tutoriales) o tambi\u00e9n podemos comprar un servomotor de rotaci\u00f3n continua listo para funcionar sin tener que hacer ning\u00fan tipo de bricolaje. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Motor / Servo\" y en la Figura 3.7.3 vemos los bloques disponibles. Figura 3.7.3. Bloques para servos Para controlar el servomotor, indicamos los grados de rotaci\u00f3n (\u00c1ngulo de giro) que queremos y el tiempo de retardo, o tiempo que tarda en ir de una posici\u00f3n a otra. El control de un servomotor de rotaci\u00f3n continua se realiza de igual manera, pero su reacci\u00f3n es diferente. Los bloques Servo-Oscilador nos permiten de una forma sencilla hacer que el servo repita una secuencia de movimientos u oscilaciones de forma indefinida. Aunque no vamos a aplicarlo en el caso de ma Smart home, un ejemplo t\u00edpico puede ser el que vemos en la Figura 3.7.4, donde el servo oscila entre 0 y 90\u00ba en periodos de dos segundos. Figura 3.7.4. Oscilaci\u00f3n con servo El bloque Servo-I2C (PCA9685) es simplemente un bloque para manejar la tarjeta controladora para 16 servos PCA9685 utilizando el bus I2C. Listas \u00b6 Las listas de datos nos permiten almacenar un listado de valores y acceder a ellos por su posici\u00f3n en la lista. Las listas pueden ser de tipo num\u00e9ricas o de texto, como vemos en la imagen siguiente: Tipos de listas en ArduinoBlocks En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n de una lista num\u00e9rica y los elementos que se crean con la misma. Los bloques que se crean nos permiten asignarle valores, saber el n\u00famero de elementos que tiene una lista, obtener el valor de una posici\u00f3n de la lista o cambiar el valor de un elemento de la lista. De forma muy similar se pueden crear y trabajar con lista de textos. Actividad A06_1 \u00b6 Esta primera actividad va a consistir en posicionar el servo de la ventana (pin 10) en posiciones prefijadas en una lista. La soluci\u00f3n la tenemos disponible en Smart-home-A06_1 . Figura 3.7.5. Soluci\u00f3n A06_1 Actividad A06_2 \u00b6 En esta actividad controlaremos la posici\u00f3n angular de la puerta mediante el servomotor al cual est\u00e1 unida. Este servomotor est\u00e1 conectado en el pin D9. La soluci\u00f3n la tenemos disponible en Smart-home-A06_2 . Figura 3.7.6. Soluci\u00f3n A06_2","title":"3.7. A06-Servomotores"},{"location":"servo/#37-a06-servomotores","text":"","title":"3.7. A06-Servomotores"},{"location":"servo/#teoria","text":"Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesita alimentaci\u00f3n ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control. Los servomotores son en realidad motores de corriente continua a los que se les ha a\u00f1adido una reductora, para que giren m\u00e1s despacio y con m\u00e1s fuerza, y un controlador electr\u00f3nico que permite hacer que gire un determinado \u00e1ngulo. Adem\u00e1s, el servo en todo momento sabe en qu\u00e9 posici\u00f3n est\u00e1, aunque se apague o reinicie. Esto significa que si a un servo que hemos movido a un determinado punto, lo hemos dejado sin alimentaci\u00f3n y al alimentarlo de nuevo le indicamos que gire 90\u00ba, no va a girar 90\u00ba sino que se va a dirigir a su posici\u00f3n de 90\u00ba que tiene memorizada internamente. En la Figura 3.7.1 vemos el interior de un servo esquematizado. Figura 3.7.1. Interior de un servo 9g Su aspecto real lo vemos en la Figura 3.7.2 donde tambi\u00e9n se aprecian las palas y tornilleria que lo acompa\u00f1an. Figura 3.7.2. Aspecto real servo 9g Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados. El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores). El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz). Hay que tener mucho cuidado de posicionar el conector de los servos en los tres pines macho de la shield en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irremediable. Existe un tipo especial de servomotor que permite la rotaci\u00f3n continua. En algunos casos se trata de servomotores \u201ctrucados\u201d de forma que se modifican para permitir la rotaci\u00f3n continua quitando los topes mec\u00e1nicos y se sustituye el potenci\u00f3metro por un divisor de tensi\u00f3n con dos resistencia iguales (en algunos casos no se ponen resistencias y se bloquea el potenci\u00f3metro para que no gire dej\u00e1ndolo justo en su punto central). Este tipo de modificaci\u00f3n la podemos realizar nosotros (en la web existen multitud de tutoriales) o tambi\u00e9n podemos comprar un servomotor de rotaci\u00f3n continua listo para funcionar sin tener que hacer ning\u00fan tipo de bricolaje. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Motor / Servo\" y en la Figura 3.7.3 vemos los bloques disponibles. Figura 3.7.3. Bloques para servos Para controlar el servomotor, indicamos los grados de rotaci\u00f3n (\u00c1ngulo de giro) que queremos y el tiempo de retardo, o tiempo que tarda en ir de una posici\u00f3n a otra. El control de un servomotor de rotaci\u00f3n continua se realiza de igual manera, pero su reacci\u00f3n es diferente. Los bloques Servo-Oscilador nos permiten de una forma sencilla hacer que el servo repita una secuencia de movimientos u oscilaciones de forma indefinida. Aunque no vamos a aplicarlo en el caso de ma Smart home, un ejemplo t\u00edpico puede ser el que vemos en la Figura 3.7.4, donde el servo oscila entre 0 y 90\u00ba en periodos de dos segundos. Figura 3.7.4. Oscilaci\u00f3n con servo El bloque Servo-I2C (PCA9685) es simplemente un bloque para manejar la tarjeta controladora para 16 servos PCA9685 utilizando el bus I2C.","title":"Teor\u00eda"},{"location":"servo/#listas","text":"Las listas de datos nos permiten almacenar un listado de valores y acceder a ellos por su posici\u00f3n en la lista. Las listas pueden ser de tipo num\u00e9ricas o de texto, como vemos en la imagen siguiente: Tipos de listas en ArduinoBlocks En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n de una lista num\u00e9rica y los elementos que se crean con la misma. Los bloques que se crean nos permiten asignarle valores, saber el n\u00famero de elementos que tiene una lista, obtener el valor de una posici\u00f3n de la lista o cambiar el valor de un elemento de la lista. De forma muy similar se pueden crear y trabajar con lista de textos.","title":"Listas"},{"location":"servo/#actividad-a06_1","text":"Esta primera actividad va a consistir en posicionar el servo de la ventana (pin 10) en posiciones prefijadas en una lista. La soluci\u00f3n la tenemos disponible en Smart-home-A06_1 . Figura 3.7.5. Soluci\u00f3n A06_1","title":"Actividad A06_1"},{"location":"servo/#actividad-a06_2","text":"En esta actividad controlaremos la posici\u00f3n angular de la puerta mediante el servomotor al cual est\u00e1 unida. Este servomotor est\u00e1 conectado en el pin D9. La soluci\u00f3n la tenemos disponible en Smart-home-A06_2 . Figura 3.7.6. Soluci\u00f3n A06_2","title":"Actividad A06_2"},{"location":"todos/","text":"Todas las actividades \u00b6 Secci\u00f3n donde disponemos de todos los programas de las actividades en formato .abp listos para importar a nuestros proyectos. Rotar servo 90\u00ba es una tarea a realizar antes de montar los servos en su posici\u00f3n: Smart-home-Rotar-servo-90.abp Parpadeo de un LED: Smart-home-A01_1.abp Control de luminosidad de un LED por PWM: Smart-home-A01_2.abp Tonos b\u00e1sicos: Smart-home-A02_1 Escala musical: Smart-home-A02_2 Partitura: Smart-home-A02_3 Melodias RTTTL: Smart-home-A02_4 Pulsador 1: Smart-home-A03_1 Pulsador 2: Smart-home-A03_2 Pulsador invertido: Smart-home-A03_3 Un pulsador enciende y el otro apaga: Smart-home-A03_4 Morse: Smart-home-A03_5 Una pulsaci\u00f3n enciende LED, dos pulsaciones mas lo apagan: Smart-home-A03_6 Funcionamiento b\u00e1sico de un rel\u00e9: Smart-home-A04_1 Control de un rel\u00e9 desde la consola: Smart-home-A04_2 Interruptor crepuscular para luz exterior: Smart-home-A05_2 Control ventana por listas: Smart-home-A06_1 Control b\u00e1sico de la puerta: Smart-home-A06_2 Control velocidad y estado del ventilador: Smart-home-A07_1 Control ventilador con pulsador: Smart-home-A07_2 Sensor de vapor como sensor t\u00e1ctil: Smart-home-A08_1 Valor anal\u00f3gico de sensor steam: Smart-home-A08_2 Alarma \u00f3ptico-ac\u00fastica por detector PIR: Smart-home-A09_1 Lectura sensor MQ-2 y datos en la consola: Smart-home-A10_1 Lectura sensor MQ-2 y datos en Serial plotter: Smart-home-A10_2 Alarma por presencia de gases con MQ-2: Smart-home-A10_3 Detecci\u00f3n de dispositivos I2C: Smart-home-detectar-IIC Escritura b\u00e1sica en la LCD: Smart-home-A11_1 Multitarea: Smart-home-A11_2 Sensor de humedad del suelo: Smart-home-A12_1 Todos los programas en un archivo comprimido: Actividades","title":"3.14. Todas las actividades"},{"location":"todos/#todas-las-actividades","text":"Secci\u00f3n donde disponemos de todos los programas de las actividades en formato .abp listos para importar a nuestros proyectos. Rotar servo 90\u00ba es una tarea a realizar antes de montar los servos en su posici\u00f3n: Smart-home-Rotar-servo-90.abp Parpadeo de un LED: Smart-home-A01_1.abp Control de luminosidad de un LED por PWM: Smart-home-A01_2.abp Tonos b\u00e1sicos: Smart-home-A02_1 Escala musical: Smart-home-A02_2 Partitura: Smart-home-A02_3 Melodias RTTTL: Smart-home-A02_4 Pulsador 1: Smart-home-A03_1 Pulsador 2: Smart-home-A03_2 Pulsador invertido: Smart-home-A03_3 Un pulsador enciende y el otro apaga: Smart-home-A03_4 Morse: Smart-home-A03_5 Una pulsaci\u00f3n enciende LED, dos pulsaciones mas lo apagan: Smart-home-A03_6 Funcionamiento b\u00e1sico de un rel\u00e9: Smart-home-A04_1 Control de un rel\u00e9 desde la consola: Smart-home-A04_2 Interruptor crepuscular para luz exterior: Smart-home-A05_2 Control ventana por listas: Smart-home-A06_1 Control b\u00e1sico de la puerta: Smart-home-A06_2 Control velocidad y estado del ventilador: Smart-home-A07_1 Control ventilador con pulsador: Smart-home-A07_2 Sensor de vapor como sensor t\u00e1ctil: Smart-home-A08_1 Valor anal\u00f3gico de sensor steam: Smart-home-A08_2 Alarma \u00f3ptico-ac\u00fastica por detector PIR: Smart-home-A09_1 Lectura sensor MQ-2 y datos en la consola: Smart-home-A10_1 Lectura sensor MQ-2 y datos en Serial plotter: Smart-home-A10_2 Alarma por presencia de gases con MQ-2: Smart-home-A10_3 Detecci\u00f3n de dispositivos I2C: Smart-home-detectar-IIC Escritura b\u00e1sica en la LCD: Smart-home-A11_1 Multitarea: Smart-home-A11_2 Sensor de humedad del suelo: Smart-home-A12_1 Todos los programas en un archivo comprimido: Actividades","title":"Todas las actividades"},{"location":"vapor/","text":"3.9. A08-Sensor de vapor (steam) \u00b6 Teor\u00eda \u00b6 El sensor de vapor es un sensor anal\u00f3gico y puede utilizarse como un simple detector de agua de lluvia, interruptor de nivel de l\u00edquido e incluso como sensor t\u00e1ctil. Cuando aumenta la humedad en la superficie del sensor, aumenta el voltaje en su salida. En la Figura 3.9.1 vemos el aspecto que tiene este dispositivo. Figura 3.9.1. Aspecto del sensor de vapor (steam) Precauci\u00f3n: las piezas de conexi\u00f3n no son impermeables, luego no debemos sumergirlo en agua Su principio de funcionamiento se base en detectar la cantidad de agua mediante pistas paralelas de la PCB que est\u00e1n esta\u00f1adas pero expuestas. Cuanta m\u00e1s agua haya, m\u00e1s cables se conectar\u00e1n entre si. El sensor es capaz de detectar vapor de agua y se puede utilizar como sensor de lluvia. Sus principales especificaciones son: Voltaje de funcionamiento: 3,3 V o 5 V. Consumo: <20mA Rango de temperatura de trabajo: \uff0d10 \u2103 a \uff0b 70 \u2103 Tipo de salida: se\u00f1al anal\u00f3gica S: se\u00f1al de salida anal\u00f3gica +: Alimentaci\u00f3n positiva (VCC) -\uff1a Alimentaci\u00f3n negativa o masa (GND) Actividad A08_1 \u00b6 En esta actividad controlaremos el diodo LED amarillo conectado al pin D5 utilizando el sensor de vapor conectado al pin A3 como sensor t\u00e1ctil. Utilizaremos el monitor serie para ver el estado de la variable creada. La soluci\u00f3n la tenemos disponible en Smart-home-A08_1 . Figura 3.9.2. Soluci\u00f3n A08_1 En la Figura 3.9.3 vemos el efecto en la consola de activar o no el sensor. Figura 3.9.3. Consola A08_1 Actividad A08_1 \u00b6 En esta actividad vamos a leer directamente el valor entregado por el sensor de vapor conectado al pin A3. Utilizaremos el monitor serie para ver el resultado. La soluci\u00f3n la tenemos disponible en Smart-home-A08_2 . Figura 3.9.4. Soluci\u00f3n A08_2 En la Figura 3.9.5 vemos el resultado de humedecer el sensor en la consola serie. Figura 3.9.5. Consola A08_2","title":"3.9. A08-Sensor de vapor (steam)"},{"location":"vapor/#39-a08-sensor-de-vapor-steam","text":"","title":"3.9. A08-Sensor de vapor (steam)"},{"location":"vapor/#teoria","text":"El sensor de vapor es un sensor anal\u00f3gico y puede utilizarse como un simple detector de agua de lluvia, interruptor de nivel de l\u00edquido e incluso como sensor t\u00e1ctil. Cuando aumenta la humedad en la superficie del sensor, aumenta el voltaje en su salida. En la Figura 3.9.1 vemos el aspecto que tiene este dispositivo. Figura 3.9.1. Aspecto del sensor de vapor (steam) Precauci\u00f3n: las piezas de conexi\u00f3n no son impermeables, luego no debemos sumergirlo en agua Su principio de funcionamiento se base en detectar la cantidad de agua mediante pistas paralelas de la PCB que est\u00e1n esta\u00f1adas pero expuestas. Cuanta m\u00e1s agua haya, m\u00e1s cables se conectar\u00e1n entre si. El sensor es capaz de detectar vapor de agua y se puede utilizar como sensor de lluvia. Sus principales especificaciones son: Voltaje de funcionamiento: 3,3 V o 5 V. Consumo: <20mA Rango de temperatura de trabajo: \uff0d10 \u2103 a \uff0b 70 \u2103 Tipo de salida: se\u00f1al anal\u00f3gica S: se\u00f1al de salida anal\u00f3gica +: Alimentaci\u00f3n positiva (VCC) -\uff1a Alimentaci\u00f3n negativa o masa (GND)","title":"Teor\u00eda"},{"location":"vapor/#actividad-a08_1","text":"En esta actividad controlaremos el diodo LED amarillo conectado al pin D5 utilizando el sensor de vapor conectado al pin A3 como sensor t\u00e1ctil. Utilizaremos el monitor serie para ver el estado de la variable creada. La soluci\u00f3n la tenemos disponible en Smart-home-A08_1 . Figura 3.9.2. Soluci\u00f3n A08_1 En la Figura 3.9.3 vemos el efecto en la consola de activar o no el sensor. Figura 3.9.3. Consola A08_1","title":"Actividad A08_1"},{"location":"vapor/#actividad-a08_2","text":"En esta actividad vamos a leer directamente el valor entregado por el sensor de vapor conectado al pin A3. Utilizaremos el monitor serie para ver el resultado. La soluci\u00f3n la tenemos disponible en Smart-home-A08_2 . Figura 3.9.4. Soluci\u00f3n A08_2 En la Figura 3.9.5 vemos el resultado de humedecer el sensor en la consola serie. Figura 3.9.5. Consola A08_2","title":"Actividad A08_1"},{"location":"ventilador/","text":"3.8. A07-M\u00f3dulo ventilador \u00b6 Teor\u00eda \u00b6 El m\u00f3dulo se componen de un motor de corriente continua a cuyo eje se puede aplicar una peque\u00f1a h\u00e9lice que se puede usar como mini ventilador o como h\u00e9lice en si misma. El m\u00f3dulo incorpora el controlador L9110 que es un puente en H que permite seleccionar el sentido de giro. Su aspecto es el de la Figura 3.8.1. Figura 3.8.1. Aspecto del m\u00f3dulo ventilador A diferencia de otros controladores o drivers como el L293D y el L298N, este solo utiliza una fuente, que ser\u00e1 la misma para alimentaci\u00f3n y control. Otra diferencia importante es que para controlar la velocidad no pose\u00e9 una entrada especifica. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\", tal y como apreciamos en la Figura 3.8.2. Figura 3.8.2. Bloque motor ventilador Actividad A07_1 \u00b6 En esta actividad controlaremos el ventilador que est\u00e1 conectado en los pines D6 y D7. Utilizaremos el pin D6 para regular la velocidad del motor y el pin D7 cuando est\u00e1 apagado o encendido. La soluci\u00f3n la tenemos disponible en Smart-home-A07_1 . Figura 3.8.3. Soluci\u00f3n A07_1 Actividad A07_2 \u00b6 En esta actividad accionaremos el ventilador mediante uno de los pulsadores y se mantendr\u00e1 en funcionamiento el tiempo que prefijemos en el programa. La soluci\u00f3n la tenemos disponible en Smart-home-A07_2 . Figura 3.8.4. Soluci\u00f3n A07_2","title":"3.8. A07-M\u00f3dulo ventilador"},{"location":"ventilador/#38-a07-modulo-ventilador","text":"","title":"3.8. A07-M\u00f3dulo ventilador"},{"location":"ventilador/#teoria","text":"El m\u00f3dulo se componen de un motor de corriente continua a cuyo eje se puede aplicar una peque\u00f1a h\u00e9lice que se puede usar como mini ventilador o como h\u00e9lice en si misma. El m\u00f3dulo incorpora el controlador L9110 que es un puente en H que permite seleccionar el sentido de giro. Su aspecto es el de la Figura 3.8.1. Figura 3.8.1. Aspecto del m\u00f3dulo ventilador A diferencia de otros controladores o drivers como el L293D y el L298N, este solo utiliza una fuente, que ser\u00e1 la misma para alimentaci\u00f3n y control. Otra diferencia importante es que para controlar la velocidad no pose\u00e9 una entrada especifica. En el apartado de bloques de programaci\u00f3n, se encuentra en \"Actuadores\", tal y como apreciamos en la Figura 3.8.2. Figura 3.8.2. Bloque motor ventilador","title":"Teor\u00eda"},{"location":"ventilador/#actividad-a07_1","text":"En esta actividad controlaremos el ventilador que est\u00e1 conectado en los pines D6 y D7. Utilizaremos el pin D6 para regular la velocidad del motor y el pin D7 cuando est\u00e1 apagado o encendido. La soluci\u00f3n la tenemos disponible en Smart-home-A07_1 . Figura 3.8.3. Soluci\u00f3n A07_1","title":"Actividad A07_1"},{"location":"ventilador/#actividad-a07_2","text":"En esta actividad accionaremos el ventilador mediante uno de los pulsadores y se mantendr\u00e1 en funcionamiento el tiempo que prefijemos en el programa. La soluci\u00f3n la tenemos disponible en Smart-home-A07_2 . Figura 3.8.4. Soluci\u00f3n A07_2","title":"Actividad A07_2"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Manual Smart Home Arduino de Innova Didactic Entrada KS0085 Keyestudio Smart Home Kit for Arduino de Keyestudio Toda la informaci\u00f3n del producto y descarga de software en el enlace . Manuales de ArduinoBlocks","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Manual Smart Home Arduino de Innova Didactic Entrada KS0085 Keyestudio Smart Home Kit for Arduino de Keyestudio Toda la informaci\u00f3n del producto y descarga de software en el enlace . Manuales de ArduinoBlocks","title":"Webgraf\u00eda y bibliograf\u00eda"}]}